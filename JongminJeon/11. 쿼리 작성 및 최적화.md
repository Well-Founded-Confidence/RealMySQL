
Real MySQL이 출간된 **2012년 즈음은 다양한 DBMS들이 우후죽순으로 탄생했던 춘추전국 시대**와 같은 시기 였으며, 아마도 그때는 **전통적인 RDBMS들은 살아남지 못하고 곧 사라질 것**이라고 생각한 사람들도 많았을 것이다.
...  중략

10년이 지난 지금, 그 누구도 그때 출시됐던 NoSQL DBMS를 언급하지 않는 듯하다(여기서 이야기하는 DBMS 범주에서 **Redis와 Memcached는 제외**했다). **그나마 HBase와 MongoDB만이 자기 자리**를 찾아서 사용되는 상황이다. 오히려 전통적인 RDBMS들은 자기만의 영역과 역할을 견고히 다져왔으며, 그중에서도 MySQL 서버는 수 많은 NoSQL DBMS를 대체하면서 발전해왔다.

앞에서 언급했던 **HBase와 MongoDB는 특정 유스케이스에 적합한 DBMS**인 반면, MySQL 서버와 같은 RDBMS는 범용 DBMS 영역에 속한다. **어떤 서비스를 개발하든  초기에는 범용 DBMS를 선택**하고, 사용량이나 데이터의 크기가 커지면 **일부 도메인 또는 테이블의 데이터만 전용 DBMS로 이전해서 확장하는 형태**를 대부분 회사에서 선택하고 있다. 그래서 어떤 서비스를 개발하더라도 RDBMS 선택을 피할 수 없으며 ...

- Hbase: Column Family NoSQL, HDFS 기반에서 돌아가는 분산되고 확장 가능한 DB
- MongoDB: Document Store NoSQL

## 11.1.  쿼리 작성과 연관된 시스템 변수
- **SQL은 어떠한 데이터를 요청하기 위한 언어**이지, **어떻게 데이터를 읽을지를 표현하는 언어는 아니다**.
- 따라서 C와 자바 같은 언와 비교했을 때 상당히 제한적으로 느껴질 수 있다.
- 그래서 **쿼리가 빠르게 수행되게 하려면 데이터베이스 서버에서 쿼리가 어떻게 요청을 처리할지 예측**할 수 있어야 한다 (그래서 **DBMS의 내부적인 처리 방식에 대해 어느 정도의 지식이 필요**하다)

- 애플리케이션 코드를 튜닝해서 성능을 2배 개선한다는 것은 쉽지 않은 일이다. 하지만 **DBMS에서 몇십 배에서 몇백 배의 성능 향상이 이뤄지는 것은 상당히 흔한 일**이다


### 11.1.1 SQL 모드

```sql
show variables where Variable_name = 'sql_mode';
>>
Variable_name,Value
sql_mode,STRICT_TRANS_TABLES
```


- STRICT_ALL_TABLES & STRICT_TRANS_TABLES: MySQL 서버에서 **INSERT나 UPDATE 문장으로 데이터를 변경하는 경우 칼럼의 타입과 저장되는 값의 타입이 다를 때 자동으로 타입 변경을 수행**한다. 이때 타입이 적절히 **변환되기 어렵거나 칼럼에 저장될 값이 없거나 값의 길이가 칼럼의 최대 길이보다 큰 경우** MySQL 서버가 INSERT나 UPDATE 문장을 계속 실행할지, 아니면 **에러를 발생시킬지를 결정**한다. 

### 11.1.2. 영문 대소문자 구분

MySQL의 DB나 테이블이 디스크의 디렉터리나 파일로 매핑된다. 
- 윈도우에 설치된 MySQL: 대소문자 구분 X
- 유닉스 계열의 운영체제: 대소문자 구분
따라서 윈도우 <-> 유닉스 운영체제간의 데이터 이동 시 문제가 발생할 수도 있다.
MySQL 서버가 운영체제와 관계없이 대소문자 구분의 영향을 받지 않게 하려면 MySQL 서버의 설정 파일에 **lower_case_table_names 시스템 변수**를 설정하면 된다. 이 변수를 1로 설정하면 모두 소문자로만 저장되고, MySQL 서버가 대소문자를 구분하지 않게 해준다

### 1.1.3. MySQL 예약어
생성하는 데이터베이스나 **테이블, 칼럼의 이름을 예약어와 같은 키워드로 생성하면 해당 칼럼이나 테이블을 SQL에서 사용하기 위해 항상 역따옴표(‵)나 쌍따옴표**로 감싸야 한다. 

## 11.2. 매뉴얼의 SQL 문법 표기를 읽는 법

![[Pasted image 20231023223331.png]]
- [] 대괄호: 선택 사항
- | 파이프: 키워드, 표현식 중 하나만 선택 가능
- {} 중괄호: 괄호 내의 아이템 중에서 반드시 하나를 사용해야함
- ...: 앞에 명시된 키워드나 표현식의 조합이 반복될 수 있음 (value_list)

## 11.3. MySQL 연산자와 내장 함수

- DBMS에서 사용되는 기본적인 연산자는 MySQL에서도 비슷하게 사용되지만 MySQL에서만 사용되는 연산자나 표기법이 있음
- 가능하면 SQL의 가독성을 높이기 위해 ANSI 표준 형태의 연산자를 사용하길 권장함

### 11.3.1. 리터럴 표기법 문자열

#### 11.3.1.1. 문자열
```sql
SELECT * FROM departments WHERE dept_no='d001'; 
SELECT * FROM departments WHERE dept_no="d001";


SQL에서 사용되는 식별자(테이블명이나 칼럼명 등)가 키워드와 충돌할 때 오라클이나 PostgreSQL에
서는 쌍따옴표나 대괄호로 감싸서 충돌을 피한다. MySQL에서는 역따옴표(‵)로 감싸서 사용하면 예약
어와의 충돌을 피할 수 있다.

CREATE TABLE tab_test (`table` VARCHAR(20) NOT NULL, ...); 
SELECT `column` FROM tab_test;
MySQL 서버의 sql_mode 시스템 변숫값에 ANSI_QUOTES를 설정하면 쌍따옴표는 문자열 리터럴 표기에 
사용할 수 없다. 그리고 테이블명이나 칼럼명의 충돌을 피하려면 역따옴표(‵)가 아니라 쌍따옴표를 사
용해야 한다

-- ANSI_QUOTES
CREATE TABLE tab_test ("table" VARCHAR(20) NOT NULL, ...); 
SELECT "column" FROM tab_test;
```

#### 11.3.1.2. 숫자

```sql
두 비교 대상이 문자열과 숫자 타입으로 다를 때는 자동으로 타입의 변환이 발생한다. 
MySQL은 숫자 타입과 문자열 타입 간의 비교에서 숫자 타입을 우선시하므로 문자열 값을 숫자 값으
로 변환한 후 비교를 수행한다

-- 1. '10001' -> 10001
SELECT * FROM tab_test WHERE number_column='10001'; 

-- 2. string_column -> number: 변환이 불가능할 수도 있고, 인덱스 컬럼이라면 형변환되어 인덱스를 사용하지 못할 수 있다.
SELECT * FROM tab_test WHERE string_column=10001;
```

#### 11.3.1.3. 날짜

```sql
SELECT * FROM dept_emp WHERE from_date='2011-04-29';
SELECT * FROM dept_emp WHERE from_date=STR_TO_DATE('2011-04-29','%Y-%m-%d');
```

#### 11.3.1.4. 불리언

```sql
mysql> CREATE TABLE tb_boolean (bool_value BOOLEAN); 
mysql> INSERT INTO tb_boolean VALUES (FALSE);
mysql> SELECT * FROM tb_boolean WHERE bool_value=FALSE; 
mysql> SELECT * FROM tb_boolean WHERE bool_value=TRUE;

mysql> CREATE TABLE tb_boolean (bool_value BOOLEAN);
mysql> INSERT INTO tb_boolean VALUES (FALSE), (TRUE), (2), (3), (4), (5); 
mysql> SELECT * FROM tb_boolean WHERE bool_value IN (FALSE, TRUE); 
+------------+
| bool_value |
+------------+ 
| 0 | 
| 1 | 
```


### 11.3.2. MySQL 연산자

#### 11.3.2.1. 동등 비교:  =, <=>

```sql
mysql> SELECT 1 = 1, NULL = NULL, 1 = NULL; 
+-------+-------------+----------+
| 1 = 1 | NULL = NULL | 1 = NULL | 
+-------+-------------+----------+
| 1     | NULL        | NULL     | 
+-------+-------------+----------+

--  "<=>" 연산자는 NULL을 하나의 값으로 인식하고 비교하는 방법
mysql> SELECT 1 <=> 1, NULL <=> NULL, 1 <=> NULL; 
+---------+---------------+------------+
| 1 <=> 1 | NULL <=> NULL | 1 <=> NULL | 
+---------+---------------+------------+ 
| 1       | 1             | 0          | 
+---------+---------------+------------+
```

#### 11.3.2.2. 부정 비교:  <>, !=

하나의 SQL 문장에서 "<>"와 "!="가 혼용되면 가독성이 떨어지므로 통일해서 사용하는 방법을 권장

#### 11.3.2.3 Not 연산자: !

```sql
-- 1.
mysql> SELECT ! 1; 
+----+
| 0 |
+----+

-- 2.
mysql> SELECT !FALSE; 
+----+ 
| 1 | 
+----+ 

-- 3.
mysql> SELECT NOT 1; 
+----+ 
| 0 | 
+----+ 

-- 4.
mysql> SELECT NOT 0; 
+----+ 
| 1 | 
+----+ 

-- 5.
mysql> SELECT NOT (1=1); 
+----+ 
| 0 | 
+----+ 
```

#### 11.3.2.4. AND(&&)와 OR(||) 연산자

SQL의 가독성을 높이기 위해 다른 용도로 사용될 수 있는 "&&" 연산자와 "||" 연산자는 사용을 자
제하는 것이 좋다
- ||: 오라클에서는 Concat, Ex. '안녕' || ' 하세요' -> 안녕하세요

```sql
-- AND, OR의 연산자 우선순위: AND

mysql> SELECT TRUE OR FALSE AND FALSE;
+-------------------------+
| TRUE OR FALSE AND FALSE |
+-------------------------+
| 1 |
+-------------------------+

mysql> SELECT TRUE OR (FALSE AND FALSE);
+---------------------------+
| TRUE OR (FALSE AND FALSE) |
+---------------------------+
| 1 |
+---------------------------+

mysql> SELECT (TRUE OR FALSE) AND FALSE;
+---------------------------+
| (TRUE OR FALSE) AND FALSE |
+---------------------------+
| 0 |
+---------------------------+
```

#### 11.3.2.5. 나누기(/, DIV)와 나머지(%, MOD) 연산자
...

#### 11.3.2.6. REGEXP 연산자

```sql
-- 문자열이 x or y or z로 시작하는지 검증하는 표현식 예제
mysql> SELECT 'abc' REGEXP '^[x-z]'; 
+-----------------------+ 
| 0 | 
+-----------------------+
```

REGEXP 연산자를 문자열 칼럼 비교에 사용할 때 **REGEXP 조건의 비교는 인덱스 레인지 스캔을 사용할 수 
없다**. 따라서 WHERE 조건절에 REGEXP 연산자를 사용한 조건을 단독으로 사용하는 것은 성능상 좋지 않
다. **가능하다면 데이터 조회 범위를 줄일 수 있는 조건과 함께 REGEXP 연산자를 사용하길 권장**


#### 11.3.1.7. Like 연산자

REGEXP 연산자보다는 훨씬 단순한 문자열 패턴 비교 연산자이지만 DBMS에서는 LIKE 연산자를 더 많이 
사용한다

```sql

-- 1.
mysql> SELECT 'abcdef' LIKE 'abc%';
+----------------------+
| 1 |
+----------------------+

-- 2.
mysql> SELECT 'abcdef' LIKE '%abc';
+----------------------+
| 0 |
+----------------------+

-- 3.
mysql> SELECT 'abcdef' LIKE '%ef';
+---------------------+
| 1 |
+---------------------+


```

LIKE 연산자는 **와일드카드 문자인 (`%`, `_`)가 검색어의 뒤쪽에 있다면 인덱스 레인지 스캔**으로 사용할 수 있지만 **와일드카드가 검색어의 앞쪽에 있다면 인덱스 레인지 스캔을 사용할 수 없으므로 주의**해서 사용해야 한다.

```
mysql> EXPLAIN
 SELECT COUNT(*)
 FROM employees 
 WHERE first_name LIKE 'Christ%';
 
+----+-----------+-------+--------------+------+--------------------------+
| id | table | type | key | rows | Extra |
+----+-----------+-------+--------------+------+--------------------------+
| 1 | employees | range | ix_firstname | 226 | Using where; Using index |
+----+-----------+-------+--------------+------+--------------------------+

mysql> EXPLAIN
 SELECT COUNT(*)
 FROM employees 
 WHERE first_name LIKE '%rist';
+----+-----------+-------+--------------+--------+--------------------------+
| id | table | type | key | rows | Extra |
+----+-----------+-------+--------------+--------+--------------------------+
| 1 | employees | index | ix_firstname | 300584 | Using where; Using index |
+----+-----------+-------+--------------+--------+--------------------------+
```

#### 11.3.2.8. BETWEEN 연산자

```sql
SELECT * FROM dept_emp
WHERE dept_no='d003' AND emp_no=10001;
SELECT * FROM dept_emp
WHERE dept_no BETWEEN 'd003' AND 'd005' AND emp_no=10001;
```

BETWEEN과 IN을 동일한 비교 연산자로 생각하는 사람도 있는데, **사실 BETWEEN은 크다와 작다 비교를 
하나로 묶어 둔 것**에 가깝다. 그리고 IN 연산자의 처리 방법은 동등 비교(=) 연산자와 비슷하다. 그림 
11.2는 이 IN과 BETWEEN 처리 과정의 차이를 보여주는데, IN 연산자는 여러 개의 동등 비교(=)를 하나로 
묶은 것과 같은 연산자라서 **IN과 동등 비교 연산자는 같은 형태로 인덱스를 사용**한다.
![[Pasted image 20231023225458.png]]


dept_emp 테이블의 인덱스(dept_no, emp_no)

```sql

-- 인덱스 선두컬럼인 dept_no가 동등 조건이 아니다.
mysql> SELECT * FROM dept_emp USE INDEX(PRIMARY)
 WHERE dept_no BETWEEN 'd003' AND 'd005' AND emp_no=10001;
+----+----------+-------+---------+---------+--------+-------------+
| id | table | type | key | key_len | rows | Extra |
+----+----------+-------+---------+---------+--------+-------------+
| 1 | dept_emp | range | PRIMARY | 20 | 165571 | Using where |
+----+----------+-------+---------+---------+--------+-------------+
# -> Filter: ((dept_emp.emp_no = 10001) and (dept_emp.dept_no between 'd003' and 'd005'))  (cost=33070 rows=0.54) (actual time=41.3..41.3 rows=1 loops=1)  
#     -> Index range scan on dept_emp using PRIMARY over ('d003' <= dept_no <= 'd005' AND emp_no = 10001)  (cost=33070 rows=164767) (actual time=0.0223..36.7 rows=91272 loops=1)


mysql> SELECT * FROM dept_emp USE INDEX(PRIMARY)
 WHERE dept_no IN ('d003', 'd004', 'd005') AND emp_no=10001;
+----+----------+-------+---------+---------+------+-------------+
| id | table | type | key | key_len | rows | Extra |
+----+----------+-------+---------+---------+------+-------------+
| 1 | dept_emp | range | PRIMARY | 20 | 3 | Using where |
+----+----------+-------+---------+---------+------+-------------+

# -> Filter: ((dept_emp.emp_no = 10001) and (dept_emp.dept_no in ('d003','d004','d005')))  (cost=2.98 rows=3) (actual time=0.0685..0.0691 rows=1 loops=1)  
#     -> Index range scan on dept_emp using PRIMARY over (dept_no = 'd003' AND emp_no = 10001) OR (dept_no = 'd004' AND emp_no = 10001) OR (dept_no = 'd005' AND emp_no = 10001)  (cost=2.98 rows=3) (actual time=0.0654..0.0659 rows=1 loops=1)

```

아래와 같이 `IN (subquery)` 형태로 쿼리 작성도 가능

```sql
SELECT * 
FROM dept_emp USE INDEX(PRIMARY)
WHERE dept_no IN ( 
 SELECT dept_no
 FROM departments -- dept_no: departments 테이블의 PK로 유니크 값 반환
 WHERE dept_no BETWEEN 'd003' AND 'd005')
 AND emp_no=10001;
```


#### 11.3.2.9. IN 연산자
- IN은 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자이다.
- 여러 개의 값이 비교되지만 범위로 검색하는 것이 아니라 여러 번의 동등 비교로 실행하기 때문에 일반적으로 빠르게 처리된다.
- **NOT IN은 인덱스 풀 스캔** (동등이 아닌 **부정형 비교여서 인덱스를 이용해 처리 범위를 줄일 수 없음**)


### 11.3.3. MySQL 내장 함수

MySQL의 함수는 MySQL에서 기본으로 제공하는 내장 함수와 사용자가 직접 작성해서 추가할 수 있는 사용자 정의 함수(UDF, UserDefined Function)로 구분된다. MySQL에서 제공하는 C/C++ API를 이용해 사용자가 원하는 기능을 직접 함수로 만들어 추가할 수 있는데, 이를 사용자 정의 함수라고 한다.
- 내장 함수나 사용자 정의 함수는 스토어드 프로그램으로 작성되는 프로시저나 스토어드 함수와는 다르므로 혼동하지 않도록 주의하자.

#### 11.3.3.1. NULL 값 비교 및 대체(IFNULL, ISNULL)

```sql
mysql> SELECT IFNULL(NULL, 1);
+-----------------+
| 1 |
+-----------------+
mysql> SELECT IFNULL(0, 1);
+--------------+
| 0 |
+--------------+
mysql> SELECT ISNULL(0);
+-----------+
| 0 |
```


#### 11.3.3.2. 현재 시각 조회(NOW, SYSDATE)

하나의 SQL에서 모든 **NOW() 함수는 같은 값**을 가지지만 **SYSDATE()함수는 하나의 SQL 내에서도 호출되는 시점에 따라 결괏값이 달라**진다.

```sql
mysql> SELECT NOW(), SLEEP(2), NOW();
+---------------------+----------+---------------------+
| NOW() | SLEEP(2) | NOW() |
+---------------------+----------+---------------------+
| 2020-08-23 14:55:20 | 0 | 2020-08-23 14:55:20 |
+---------------------+----------+---------------------+


mysql> SELECT SYSDATE(), SLEEP(2), SYSDATE();
+---------------------+----------+---------------------+
| SYSDATE() | SLEEP(2) | SYSDATE() |
+---------------------+----------+---------------------+
| 2020-08-23 14:55:23 | 0 | 2020-08-23 14:55:25 |
+---------------------+----------+---------------------+
```

SYSDATE() 함수는 위에서도 언급했듯이 이 함수가 호출될 때마다 다른 값을 반환하므로 사실은 상수가 
아니다. 그래서 인덱스를 스캔할 때도 매번 비교되는 레코드마다 함수를 실행해야 한다. 하지만 **NOW()
함수는 쿼리가 실행되는 시점에서 실행되고 값을 할당받아서 그 값을 SQL 문장의 모든 부분에서 사용
하기 때문에 쿼리가 1시간 동안 실행되더라도 실행되는 위치나 시점에 관계없이 항상 같은 값을 보장**할 수 있다.

일반적인 웹 서비스에서는 특별히 SYSDATE() 함수를 사용해야 할 이유가 없다. 시스템 설정 파일(my.cnf)
에 sysdate-is-now 시스템 변수를 추가해서 **SYSDATE() 함수가 NOW() 함수와 동일하게 작동하게 설정할 
것을 권장**한다.

#### 11.3.3.3. 날짜와 시간의 포맷(DATE_FORMAT, STR_TO_DATE)


```sql
mysql> SELECT DATE_FORMAT(NOW(), '%Y-%m-%d') AS current_dt;
+------------+
| current_dt |
+------------+
| 2020-08-23 |
+------------+

mysql> SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s') AS current_dttm;
+---------------------+
| current_dttm |
+---------------------+
| 2020-08-23 15:06:45 |
+---------------------+


mysql> SELECT STR_TO_DATE('2020-08-23','%Y-%m-%d') AS current_dt;
+------------+
| current_dt |
+------------+
| 2020-08-23 |
+------------+
mysql> SELECT STR_TO_DATE('2020-08-23 15:06:45','%Y-%m-%d %H:%i:%s') AS current_dttm;
+---------------------+
| current_dttm |
+---------------------+
| 2020-08-23 15:06:45 |
+---------------------+
```


#### 11.3.3.4. 날짜와 시간의 연산(DATE_ADD, DATE_SUB)

- DATE_ADD() 함수로 더하거나 빼는 처리를 모두 할 수 있기 때문에 DATE_SUB()는 크게 필요하지 않다

```sql
mysql> SELECT DATE_ADD(NOW(), INTERVAL 1 DAY) AS tomorrow;
+---------------------+
| tomorrow |
+---------------------+
| 2020-08-24 15:11:07 |
+---------------------+

mysql> SELECT DATE_ADD(NOW(), INTERVAL -1 DAY) AS yesterday;
+---------------------+
| yesterday |
+---------------------+
| 2020-08-22 15:11:07 |
+---------------------+
```


#### 11.3.3.5. 타임스탬프 연산(UNIX_TIMESTAMP, FROM_UNIXTIME)

```
-- "Unix 에포크 시간" 또는 "Unix 타임 스탬프"
-- 에포크(Epoch) 시간은 1970년 1월 1일 00:00:00(UTC)부터 경과한 시간을 초로 나타내는 것

mysql> SELECT UNIX_TIMESTAMP();
+------------------+
| UNIX_TIMESTAMP() |
+------------------+
| 1598163535 |
+------------------+

mysql> SELECT UNIX_TIMESTAMP('2020-08-23 15:06:45');
+---------------------------------------+
| UNIX_TIMESTAMP('2020-08-23 15:06:45') |
+---------------------------------------+
| 1598162805 |
+---------------------------------------+


mysql> SELECT FROM_UNIXTIME(UNIX_TIMESTAMP('2020-08-23 15:06:45'));
+------------------------------------------------------+
| FROM_UNIXTIME(UNIX_TIMESTAMP('2020-08-23 15:06:45')) |
+------------------------------------------------------+
| 2020-08-23 15:06:45 |
```
