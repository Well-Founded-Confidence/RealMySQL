# 5. 트랜잭션과 잠금
## 5.1. 트랜잭션
### 5.1.1. MySQL에서의 트랜잭션

### 5.1.2. 주의사항
- 트랜잭션은 최소한의 크기로 만든다.
- 트랜잭션에 네트워크 요청이 있으면 불안정하다.
회사 사례: 주문생성과 Payment 트랜잭션 분리
```
```

## 5.2. MySQL 엔진의 잠금
- 스토리지엔진 레벨
- MySQL엔진 레벨 (스토리지 엔진을 제외한 모든 부분)
### 5.2.1. 글로벌 락
- Flush Tables with read lock
### 5.2.2. 테이블 락
### 5.2.3. 네임드 락
### 5.2.4. 메타데이터 락
- 테이블의 구조를 잠근다.

## 5.3. InnoDB 스토리지 엔진 잠금
### 5.3.1. InnoDB 스토리지 엔진의 잠금
- 락 에스컬레이션: 잠금 정보가 더 큰 범위로 올락는 경우 (ex. 레코드 락 -> 페이지 락, 레코드 락, 페이지 락 -> 테이블 락)
  
![alt](./src/img/5.1.%20InnoDB%20%EC%9E%A0%EA%B8%88%EC%9D%98%20%EC%A2%85%EB%A5%98.png)
#### 5.3.1.1. 레코드 락
- InnoDB 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠금
#### 5.3.1.2. 갭 락 
#### 5.3.1.3. 넥스트 키 락
- 레코드 락 + 갭 락
- 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생함
- 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋음

#### 5.3.1.4. 자동 증가 락
- Auto_increment 락 (테이블 수준의 잠금)
- Insert, Replace 쿼리에서만 아주 잠시 락을 걸었다가 해제 함
- innodb_autoinc_lock_mode 값을 0~2로 조절해서 락 보다 가벼운 래치(뮤텍스)를 이용해 처리할 수 있다.
  - 높은 값일 수록 가벼운 잠금
- MySQL 8.0 부터는 기본 값이 2로 되었음
뮤텍스, 출처: Bard
```
물론입니다. 뮤텍스는 컴퓨터 과학에서 공유 리소스에 대한 동시 액세스를 방지하는 데 사용되는 동기화 도구입니다. "상호 배제"라는 용어의 약자입니다. 뮤텍스는 액세스하려는 프로세스에 의해 잠기고 잠금 해제될 때까지 다른 프로세스에 의해 액세스할 수 없습니다.

뮤텍스는 공유 메모리, 파일 및 데이터베이스와 같은 다양한 리소스를 보호하는 데 사용할 수 있습니다. 예를 들어, 여러 프로세스가 동일한 파일에 액세스해야 하는 경우 뮤텍스를 사용하여 한 번에 하나의 프로세스만 파일에 액세스할 수 있도록 할 수 있습니다.

뮤텍스는 락이라고도 하는 프로세스의 변수로 구현됩니다. 뮤텍스는 0 또는 1로 설정할 수 있습니다. 뮤텍스가 0으로 설정되면 뮤텍스가 잠겨 있고 다른 프로세스가 액세스할 수 없습니다. 뮤텍스가 1로 설정되면 뮤텍스가 잠금 해제되어 다른 프로세스가 액세스할 수 있습니다.

프로세스가 뮤텍스를 획득하려면 뮤텍스가 잠금 해제되어 있는지 확인한 다음 뮤텍스를 1로 설정해야 합니다. 프로세스가 뮤텍스를 해제하려면 뮤텍스를 0으로 설정해야 합니다.

뮤텍스는 프로세스 간의 충돌을 방지하는 데 중요합니다. 뮤텍스가 없으면 두 프로세스가 동시에 공유 리소스에 액세스하려고 할 수 있으며 이는 데이터 손상이나 기타 문제를 일으킬 수 있습니다.

뮤텍스는 컴퓨터 과학에서 중요한 도구입니다. 그들은 충돌을 방지하고 공유 리소스에 대한 동시 액세스를 제어하는 데 사용됩니다.
```
### 5.3.2. 인덱스와 잠금
- Update할 때 스캔하는 모든 데이터를 잠금 처리 한다.
![alt](./src/img/5.2.%20%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%A5%BC%20%EC%9C%84%ED%95%B4%20%EC%9E%A0%EA%B8%B4%20%EB%A0%88%EC%BD%94%EB%93%9C%EC%99%80%20%EC%8B%A4%EC%A0%9C%20%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%90%9C%20%EB%A0%88%EC%BD%94%EB%93%9C.png)
- 테이블을 풀 스캔하는 경우에는 테이블의 모든 레코드를 잠그게 된다.
  - 이것이 MySQL의 방식이고, InnoDB에서 인덱스 설계가 중요한 이유 이다.


### 5.3.3. 레코드 수준의 잠금 확인 및 해제

## 5.4. MySQL의 격리 수준
- 1~4 단계로 갈수록 격리 수준이 강화됨
- 보통 2~3 단계를 사용함
- 1 단계는 트랜잭션의 격리수준으로 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준
- 4 단계는 동시성이 중요한 데이터베이스에서는 거의 사용되지 않음

![alt](./src/img/5.%20%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80%20%ED%91%9C.png)

### 5.4.1. READ UNCOMMITTED
- 더티 리드: 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상

### 5.4.2. READ COMMITTED
- 커밋된 데이터만 읽는다. (Oracle 기본 값)
- 문제점: NON-REPEATABLE READ 발생
    - 하나의 트랜잭션에서 동일한 Select 문을 실행했을 때 Select 결과가 다를 수도 있다. (하나의 트랜잭션)

### 5.4.3. REPEATABLE READ
- NON-REPEATABLE READ가 발생하지 않는다.
- InnoDB 스토리지 엔진에서 기본으로 사용
- REPEATABLE READ와 READ COMMITTED의 차이는 언두 영역에 백업된 레코드의 여러 버전 가 운데 몇 번째 이전 버전까지 찾아 들어가야 하느냐의 차이
- 현재 실행중인 트랜잭션 이후에 발생한 언두 로그는 삭제할 수 없다.
- InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 격리 수준에서도 이미 “PHANTOM READ”가 발생하지 않는다.

### 5.4.4. SERIALIZABLE
- 읽기 작업도 잠금 처리한다.