# 8. 인덱스
- 쿼리 개발, 튜닝 전 인덱스의 종류 및 특성 살펴 보기
- 옵티마이저의 성능이 개선 되었지만 관리자 역할은 여전히 중요

## 8.1. 디스크 읽기 방식
- 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건
### 8.1.1. 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
![alt](./src/img/8.1.%20%EC%A3%BC%EC%9A%94%20%EC%9E%A5%EC%B9%98%EC%9D%98%20%EC%B4%88%EB%8B%B9%20%EC%B2%98%EB%A6%AC%20%ED%9A%9F%EC%88%98.png)
- 디스크에서 데이터를 읽어오는 작업이 데이터 조회/처리의 병목이다.
### 8.1.2. 랜덤 I/O와 순차 I/O
![alt](./src/img/8.3.%20%EC%88%9C%EC%B0%A8%2C%EB%9E%9C%EB%8D%A4.png)
- 디스크에 데이터를 기록 하기 위해 1번 시스템 콜을 하느냐 여러번 시스템 콜을 하느냐
- 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정
- 디스크 헤더의 움직임 횟수를 줄이기 위해 그룹 커밋, 로그 버퍼, InnoDB 로그 버퍼 사용 (모아서 처리)
- 쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 거의 없다.
  - 따라서 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이다
  - 여기서 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미


```
인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하며, 풀 테이블 스캔은 순차 I/O를 사용한다. 그
래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때
도 있다. 이는 순차 I/O가 랜덤 I/O보다 훨씬 빨리 많은 레코드를 읽어올 수 있기 때문인데, 이런 형태는 OLTP(On-Line Transaction Processing) 성격의 웹 서비스보다는 데이터 웨어하우스나 통계 작업에서 자주 사용된다
```

## 8.2. 인덱스란?
- SortedList: 정렬 된 자료 구조 (인덱스)
  - 데이터 추가/변경/삭제 시 정렬이 필요해 추가/변경/삭제 속도가 느려질 수 있음
- ArrayList: 별도 정렬이 없는 자료 구조 (데이터 파일)
- 저장 속도와 읽기 속도의 Trade Off

- Primary Key: 레코드를 식별할 수 있는 식별자, Not Null and Unique
- Secondary Key: Unique, Non-Unique

- Unique, Non-Unique는 옵티마이저에게는 상당히 중요한 문제가 된다.
  - 유니크 인덱스에 대해 동등 조건(Equal, =)으로 검색하면 것은 항상 1건의 레코드만 찾고 종료할 수 있다.

## 8.3. B-Tree 인덱스
- Balanced 트리
- Not Binary
### 8.3.1. 구조 및 특성
![alt](./src/img/8.4.%20B-Tree%20%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98%20%EA%B5%AC%EC%A1%B0.png)
- 루트 노드, 리프 노드, 중간에 브랜치 노드
```
대부분 RDBMS의 데이터 파일에서 레코드는 특정 기준으로 정렬되지 않고 임의의 순서로 저장된다. 하지만 
InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된
다. 이는 오라클의 IOT(Index organized table)나 MS-SQL의 클러스터 테이블과 같은 구조를 말한다
```
- InnoDB는 세컨더리 인덱스 생성 시 PK를 주소처럼 사용한다.
- 따라서 세컨더리 인덱스로 데이터를 읽을 때는 Primary Key Index의 리프 페이지에 저장되어 있는 레코드를 읽어온다.
  - 매우 비효율 적으로 보인다 (8.8절 클러스터링 인덱스에서 추가설명이 있다고 합니다.)
### 8.3.2. B-Tree 인덱스 키 추가 및 삭제
- 체인지 버퍼
- 프라이머리 키나 Unique 인덱스인 경우 중복확인 작업이 필요해 버퍼 없이 바로 바로 적용
- 삭제: 삭제로 마킹하는 소프트 Delete
- 변경: 삭제 후 추가하는 방법

인덱스 키 검색
- 전방일치
```
(X)
select * from user
where name like '%길동'
(O)
select * from user
where name like '홍%'
```
- 인덱스 컬럼 가공 X
```
(X)
select * from user
where date_format(created_date, '%Y-%m-%d') = '2023-05-16'

(O)
select * from user
where created_date = to_date('2023-05-16', '%Y-%m-%d)

```
  
### 8.3.3. B-Tree 인덱스 사용에 영향을 미치는 요소
- 인덱스 컬럼 크기, 레코드의 건수, 유니크 인덱스의 개수 등
- 데이터를 저장하는 기본단위: Page 또는 Block이라고 한다.
- InnoDB 버퍼풀에 데이터를 저장하는 기본 단위도 Page 이다.
 
#### 8.3.3.1. 인덱스 키 값의 크기
![alt](./src/img/8.7.%20%EC%9D%B8%EB%8D%B1%EC%8A%A4%20%ED%8E%98%EC%9D%B4%EC%A7%80%EC%9D%98%20%EA%B5%AC%EC%84%B1.png)
- 페이지 1개에 담을 수 있는 인덱스 개수가 적어짐
- 인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것을 의미 (버퍼 풀, 저장소 용량은 한정적)
- 
#### 8.3.3.2. B-Tree 깊이
```
키 값이 16바이트인 경우에는 최대 2억(585 * 585 * 585)개 정도의 키 값을 담을 수 있지만, 키 값이 
32바이트로 늘어나면 5천만(372 * 372 * 372) 개로 줄어든다.
```

#### 8.3.3.3. 선택도(기수성)
- 옵티마이저는 통계정보를 참고한다.
- 1000개 rows, 1번 컬럼에 unique값이 10개 = 100
  - 여기서 unique 값 별로 몇 개의 rows를 가지고 있는지 까지는 저장 X

#### 8.3.3.4. 읽어야 하는 레코드 건수
- 인덱스를 이용한 읽기의 손익 분기점 (일반적으로 20~25%)
- 100만 건에서 50만 건을 조회해야하는 경우 Full Sacn
- 인덱스를 통해 레코드를 읽는 것이 순차적으로 데이터를 읽는 것 보다 비싼 작업이기 때문에
  - 인덱스를 통해 데이터를 읽는다: B-Tree 탐색 후 리프노드에서 레코드의 메모리 주소를 얻어서 조회


### 8.3.4. B-Tree 인덱스를 통이 데이터 읽기

#### 8.3.4.1. 인덱스 레인지 스캔
- 우리가 인덱스를 탔다고 말하는 일반적인 경우
- 읽으려는 데이터의 시작점과 종료점을 찾아서 조회함

![alt](./src/img/8.8.%20%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%A5%BC%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20%EB%A0%88%EC%9D%B8%EC%A7%80%20%EC%8A%A4%EC%BA%94.png)
```
1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. 이 과정을 인덱스 탐색(Index seek)이라고 한다.
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다. 이 과정을 인덱스 스캔(Index scan)이라고 한
다. (1번과 2번 합쳐서 인덱스 스캔으로 통칭하기도 한다.)
1. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어 온다.
```

- 인덱스에 구성된 데이터만으로 원하는 데이터를 얻을 수 있다면 3번 과정의 생략됨 (커버링 인덱스, 빠름)

#### 8.3.4.2. 인덱스 풀 스캔
- 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용된다
- 인덱스 데이터가, 전체 테이블 데이터보다 작기에 빠르다.

#### 8.3.4.3. 루스 인덱스 스캔

![alt](./src/img/8.11.%20%EB%A3%A8%EC%8A%A4%20%EC%9D%B8%EB%8D%B1%EC%8A%A4%20%EC%8A%A4%EC%BA%94.png)

```
mysql> SELECT dept_no, MIN(emp_no)
 FROM dept_emp
 WHERE dep_no BETWEEN 'd002' AND 'd004' 
 GROUP BY dept_no;
```
- 부서 번호별 사원번호가 가장 낮은 사원 정보 추출하기

#### 8.3.4.4. 인덱스 스킵 스캔
- 인덱스 선두 컬럼을 Where절에 반드시 포함해야 했는데 포함하지 않아도 인덱스 스캔이 가능

일반 적인 경우
```
mysql> ALTER TABLE employees 
 ADD INDEX ix_gender_birthdate (gender, birth_date);

 -- // 인덱스를 사용하지 못하는 쿼리
mysql> SELECT * FROM employees WHERE birth_date>='1965-02-01';
-- // 인덱스를 사용할 수 있는 쿼리
mysql> SELECT * FROM employees WHERE gender='M' AND birth_date>='1965-02-01';
```

![alt](./src/img/8.12.%20%EC%9D%B8%EB%8D%B1%EC%8A%A4%20%EC%8A%A4%ED%82%B5%20%EC%8A%A4%EC%BA%94.png)


Skip Scan
```
mysql> SET optimizer_switch='skip_scan=on';
mysql> EXPLAIN
 SELECT gender, birth_date 
 FROM employees
 WHERE birth_date>='1965-02-01';
+----+-----------+-------+---------------------+----------------------------------------+
| id | table | type | key | Extra |
+----+-----------+-------+---------------------+----------------------------------------+
| 1 | employees | range | ix_gender_birthdate | Using where; Using index for skip scan |
+----+-----------+-------+---------------------+----------------------------------------+
```

인덱스 스킵 스캔이 유용하거나 동작하는 경우
```
1. WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
2. 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)
```

### 8.3.5. 다중 칼럼(Multi-Column) 인덱스

![alt](./src/img/8.13.%20%EB%8B%A4%EC%A4%91%20%EC%B9%BC%EB%9F%BC%20%EC%9D%B8%EB%8D%B1%EC%8A%A4.png)
```
그림 8.13에서는 칼럼
이 2개뿐이지만, 만약 칼럼이 4개인 인덱스를 생성한다면 세 번째 칼럼은 두 번째 칼럼에 의존해서 정
렬되고 네 번째 칼럼은 다시 세 번째 칼럼에 의존해서 정렬된다
```

```
그래서 위의 그림에서 emp_no 값이 “10003”인 레코드가 인덱스 리프 노드의 제일 마지막(하단)에 위치하는 것이다. 다
중 칼럼 인덱스에서는 인덱스 내에서 각 칼럼의 위치(순서)가 상당히 중요하며, 그것을 아주 신중히 결정해야 하는 이유가 바로 그것이다
```


- ~ 2023-05-**16**