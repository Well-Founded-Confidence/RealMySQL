
# 9. 옵티마이저와 힌트
- 여행 시 인터넷이 책 등을 참고하여 최소한의 비용이 드는 방법을 찾는 것 처럼
- 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장되어 있는지 통계정보 참조
- DBMS에서는 옵티마이저가 이 기능을 담당


## 9.1. 개요

### 9.1.1. 쿼리 실행 절차
1. SQL 문장 쪼개기 (파스 트리)
2. 실행 계획 생성
3. 스토리지 엔진에서 데이터 가져오기

### 9.1.2. 옵티마이저의 종류
- 비용 기반 최적화 (현재 대부분의 DBMS)
- 규칙 기반 최적화 (올드)

## 9.2. 기본 데이터 처리

### 9.2.1. 풀 테이블 스캔과 풀 인덱스 스캔
- 중요한 것 같음

### 9.2.2. 병렬 처리

### 9.2.3. Order by 처리 (Using filesort)

#### 9.2.3.1. 소트 버퍼
- 임계 값을 넘어가면 성능에 별 영향이 없거나 오히려 성능이 떨어진다.

#### 9.2.3.2. 정렬 알고리즘
- 싱글 패스: 정렬 키와 레코드의 Row ID만 가져와서 정렬 후 Row ID로 데이터를 읽어오는 방식
- 투 패스: 레코드 전체를 가져와서 정렬하는 방식

##### 9.2.3.2.1. 싱글 패스 정렬 방식
- 싱글 패스가 합리적으로 보인다, 하지만 소트 버퍼 공간을 많이 차지 한다.

##### 9.2.3.2.2. 투 패스 정렬 방식
- 투 패스 정렬 방식은 언제 사용할까?
- 정렬 대상 레코드의 크기, 건수가 많을 때 효율적


#### 9.2.3.3. 정렬 처리 방법

##### 9.2.3.3.1. 인덱스를 이용한 정렬
- 정렬하지 않아도 되기에 베스트 이다.

##### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬
- 드라이빙 테이블을 먼저 정렬하고 드리븐 테이블의 값들을 조인한다.
- 조건
  - Nested Loop 조인이여야 한다 (해시 조인 시 불가)
  - Order by 조건 컬럼이 드라이빙 테이블에 있는 컬럼이여야 한다.
  - Where 절 조건 컬럼이 드라이빙 테이블에 있는 컬럼이여야 한다. (확인 필요)

##### 9.2.3.3.3. 임시 테이블을 이용한 정렬
- Using Where; Using temporary; Using filesort

##### 9.2.3.3.4. 정렬 처리 방법의 성능 비교


###### 9.2.3.3.4.1. 스트리밍 방식
- 서버 쪽에서 처리할 데이터가 얼마인지에 관계 없이 조건에 일치하는 레코드가 검색 될 때 마다 클라이언트로 보냄
- 이 방식으로 쿼리를 처리하면 클라이언트는 쿼리 요청 후 곧바로 원했던 첫 번째 레코드를 받음
- 마지막 레코드는 언제 받을지 알 수 없지만, 그다지 중요하지 않은 경우에 사용
- 예시: 페이지 네이션

###### 9.2.3.3.4.2. 버퍼링 방식 

#### 9.2.3.4. 정렬 관련 상태 변수

### 9.2.4. Group by 처리

#### 9.2.4.1. 인덱스 스캔을 이용하는 Group by (타이트 인덱스 스캔)
- Using temporary, Using filesort가 생략됨

#### 9.2.4.2. 루스 인덱스 스캔을 이용하는 Group by

#### 9.2.4.3. 임시 테이블을 사용하는 Group by

### 9.2.5. Distinct 처리

#### 9.2.5.1. Select distinct

#### 9.2.5.2. 집합 합수와 함께 사용된 Distinct

### 9.2.6. 내부 임시 테이블 활용
- MySQL 8.0 부터 바뀐부분이 많음
- 임시 테이블이 메모리를 사용할 경우: Memory 엔진 -> TempTable 엔진
- 임시 테이블이 디스크를 사용할 경우: MyISAM -> InnoDB or MMAP

#### 9.2.6.1. 메모리 임시 테이블과 디스크 임시 테이블

#### 9.2.6.2. 임시 테이블이 필요한 쿼리

#### 9.2.6.3. 임시 테이블이 디스크에 생성되는 경우 

#### 9.2.6.4. 임시 테이블 관련 상태 변수
- 확인 가능하다.


## 9.3. 고급 최적화

## 9.4. 쿼리 힌트