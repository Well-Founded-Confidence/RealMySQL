# 8.3 B-Tree 인덱스

B-Tree 인덱스는 가장 일반적으로 사용되고 가장 먼저 도입된 알고리즘이다.

DBMS에서는 주로 B+-Tree 또는 B\*-Tree가 사용된다.

> 여기서 B는 Balance를 의미한다.

## 8.3.1 구조 및 특성

최상위에 하나의 루트 노드가 존재하고 하위에 자식 노드가 붙어 있는 형태다.
트리 구조의 가장 하위에 있는 노드를 리프 노드라 하고, 루트도 리프도 아닌 노드를 브랜치 노드라 한다.

DB에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.

![8.4 B-Tree 인덱스 구조](../resources/8.4%20B-Tree%20%EC%9D%B8%EB%8D%B1%EC%8A%A4%20%EA%B5%AC%EC%A1%B0.png)

인덱스 키 값은 모두 정렬돼 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다.

만약, 레코드가 삭제되어 빈 공간이 생기면 그 다음의 INSERT는 가능한 한 삭제된 공간을 재활용하도록 DBMS가 설계해놨다.
따라서, 항상 INSERT 된 순서로 저장되는 것은 아니다.

> InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 PK 순서로 정렬되어 저장된다.

![B-Tree의 리프 노드와 테이블 데이터 레코드 InnoDB](../resources/8.6%20B-Tree의%20리프%20노드와%20테이블%20데이터%20레코드.png)

인덱스에 저장된 pk 값을 이용해 pk index를 한번 더 검색 후, pk index의 리프 페이지에 저장돼 있는 레코드를 읽는다.

즉, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 PK를 저장하고 있는 B-Tree를 다시 한번 검색해야 한다.

## 8.3.2 B-Tree 인덱스 키 추가 및 삭제

테이블 레코드를 저장/변경하는 경우 index 키 추가/삭제가 발생한다. 이것이 어떻게 처리되는지 알아두면 쿼리 성능을 쉽게 예측할 수 있을 것이다.

### 8.3.2.1 인덱스 키 추가

리프 노드가 꽉 차서 더는 저장할 수 없을땐 리프 노드가 분리(split) 돼야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다.

이러한 작업 탓에 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 드는 것으로 알려졌다.

InnoDB에서는 INSERT 실행 후 새로운 키 값을 저장할 수도 있고 지연시킬 수도 있다.  
하지만, PK나 유니크 인덱스는 중복 체크가 필요하므로 즉시 B-Tree에 추가/삭제한다.

### 8.3.2.2 인덱스 키 삭제

B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 된다. 이는 계속 방치되거나 재활용된다.
MySQL 5.5 이상의 InnoDB에서는 이 작업도 버퍼링되어 지연처리될 수 있다.

### 8.3.2.3 인덱스 키 변경

인덱스 키 값에 따라 저장될 리프 노드 위치가 결정되므로 B-Tree 키 값이 변경되는 경우에는 단순히 인덱스상의 키 값만 변경하는 것을 불가능하다.

먼저 키를 삭제하고, 다시 새로운 키 값을 추가하는 형태로 처리한다.
InnoDB에서는 이 모두 체인지 버퍼를 활용해 지연처리 할 수 있다.

### 8.3.2.4 인덱스 키 검색

INSERT UPDATE DELETE 작업을 할 때 인덱스 관리의 추가비용을 감당하며 구축하는 이유는 바로 **빠른 검색을 위해서다.**

인덱스 검색 작업은 B-Tree의 루트-브랜치-리프 노드까지 이동하며 비교 작업을 수행할텐데 이를 `트리 탐색`이라 한다.

B-Tree 인덱스를 이용한 검색은 100% 일치하거나 값의 앞부분만 일치하는 경우에 사용할 수 있다.

> 그래서 like '%abc%' 같은건 풀스캔 일어나는듯

InnoDB에서 지원하는 레코드 잠금이나 갭락은 적절히 사용할 수 있는 인덱스가 없다면 최악의 경우 테이블 락까지 걸 수 있다.

## 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

### 8.3.3.1 인덱스 키 값의 크기

인덱스 `페이지` 크기와 키 값의 크기에 따라 B-Tree 자식 노드 갯수가 정해진다.

인덱스의 크기가 늘어나면 당연히 한 페이지에 저장할 수 있는 인덱스가 줄어든다.
즉, 디스크 I/O가 늘어난다는 뜻이다.

또한, InnoDB 버퍼풀에에 인덱스 캐시해두는 영역의 효율도 떨어진다.

### 8.3.3.2 B-Tree 깊이

B-Tree의 깊이는 상당히 중요하지만 직접 제어할 방법은 없다.

depth 3인 경우 키 값이 16바이트일때, 최대 2억(585*585*585)개 정도의 키 값을 담을 수 있으나, 32바이트로 늘어나면 5천만(372*372*372)개로 줄어든다.

이 깊이는 MySQL에서 디스크 I/O와 직결되는 문제다.

결론은, 키 값은 작을수록 좋다.

### 8.3.3.3 선택도(기수성)

모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.

전체 인덱스가 100, 유니크 값이 10이라면 기수성은 10이다.

이 선택도가 높을수록 검색 대상이 줄기에 그만큼 빨라진다.

### 8.3.3.4 읽어야 하는 레코드의 건수

100만건 레코드 중 50만건 레코드를 읽어야 할 때, 인덱스를 통해 읽는게 나을까 아니면 전체 테이블을 모두 읽는게 나을까?

일반적인 DBMS 옵티마이저는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업인 것으로 예측한다.

즉, 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 테이블 전체를 읽는다.

## 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

### 8.3.4.1 인덱스 레인지 스캔

```mysql
SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```

검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.

범위 검색으로 PK를 가져오고, 랜덤 디스크 I/O를 통해 실제 데이터를 가져온다.

1. 인덱스에서 조건을 만족하는 값이 저장된 위치 찾는다 (인덱스 탐색 Index seek)
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다. (인덱스 스캔 Index scan)
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고 최종 레코드를 읽어온다.

※ 여기서 스캔과 탐색의 차이를 기억해두면 좋다.

### 8.3.4.2 인덱스 풀 스캔

인덱스 처음부터 끝까지 모두 읽는 방식이다.

쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 사용된다.

예를들어, 인덱스는 A, B, C로 만들어져 있으나 실제 검색은 B나 C 컬럼으로 검색하는 경우다.

쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용된다.
만약, 레코드까지 읽어야하면 절대 이 방식으로 처리되지 않는다.

레인지 스캔보다 느리지만, 풀 테이블 스캔보다는 효율적이다.

### 8.3.4.3 루스 인덱스 스캔

느슨하게, 듬성듬성하게 인덱스를 읽는 것을 의미한다.

필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 것이며 일반적으로 GROUP BY나 MAX(), MIN() 함수에 대해 최적화를 할 때 쓰인다.

```mysql
# dept_no, emp_no가 인덱스임

SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dep_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;
```

dept_no, emp_no는 이미 정렬되어 있으니까 각 dept_no의 첫번째 emp_no만 읽으면 된다.

### 8.3.4.4 인덱스 스킵 스캔

위 예시에서 emp_no에 대한 검색만 하면 인덱스를 다시 생성해야 했다.
8.0부터 옵티마이저가 앞 컬럼을 건너 뛰고 검색을 가능하게 해주는 스킵 스캔 최적화 기능이 도입됐다.

## 8.3.5 다중 컬럼 인덱스

## 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

인덱스는 설정한 정렬 규칙에 의해 내림차순 또는 오름차순으로 정렬되는데 인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어 내는 실행 계획에 따라 결정된다.

### 8.3.6.1 인덱스의 정렬

MySQL 8.0 이전에는 컬럼 단위로 정렬 순서를 정할 수 없어서 -1를 곱하곤 했다. (모두 오름차순으로 설정됐었음)
하지만 8.0부터 순서를 혼합한 인덱스도 생성할 수 있게 됐다.

```mysql
CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_scroe DESC);
```

### 8.3.6.1.1 인덱스 스캔 방향

```mysql
SELECT *
FROM employees
ORDER BY first_name DESC
LIMIT 1;
```

인덱스를 사용하는 시점에 인데스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다.

즉, 위 쿼리는 인덱스를 역순으로 접근해 첫 번째 레코드만 읽으면 된다.

### 8.3.6.1.2 내림차순 인덱스

```mysql
CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
```

복합 인덱스에서 각 컬럼 정렬이 혼합된 경우 내림차순 인덱스롬나 해결될 수 있다.
만약 둘 다 역순이면 어떻게 될까

아래 용어를 정의하고 가자

- 오름차순 인덱스 ASC: 작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬
- 내림차순 인덱스 DESC: 큰 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬
- 인덱스 정순 스캔(Forward index scan): 인덱스 키의 크고 작읍에 관계없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
- 인덱스 역순 스캔(Backward index scan): 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔

MySQL 서버의 InnoDB 스토리지 엔진에서 정순 스캔과 역순 스캔은 페이지(블록) 간의 양방향 연결 고리(Double linked list)를 통해 전진(Forward) 하느냐 후진(Backward)하느냐의 차이만 있지만, 실제 내부적으로는 InnoDB에서 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느릴 수밖에 없는 다음의 두 가지 이유가 있다.

- 페이지 잠금이 인덱스 정순 스캔(Forward index scan)에 적합한 구조
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조(아래 그림 참고)

![InnoDB 페이지 내에서 레코드들의 연결](../resources/8.16%20InnoDB%20%ED%8E%98%EC%9D%B4%EC%A7%80%20%EB%82%B4%EC%97%90%EC%84%9C%20%EB%A0%88%EC%BD%94%EB%93%9C%EB%93%A4%EC%9D%98%20%EC%97%B0%EA%B2%B0.png)

결론은,

일반적으로 인덱스를 ORDER BY ... DESC 하는 쿼리가 소량의 레코드에 드물게 실행되는 경우라면 내림차순 인덱스를 굳이 고려할 필요는 없다.

하지만 빈번하다면 오름차순 인덱스보다는 내림차순 인덱스가 더 효율적이라고 볼 수 있다.

또한 많은 쿼리가 인덱스의 앞쪽만 또는 뒤쪽만 집중적으로 읽어서 인덱스의 특정 페이지 잠금이 병목이 될 것으로 예상된다면 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는 데 도움이 될 것이다.

## 8.3.7 B-Tree 인덱스의 가용성과 효율성

### 8.3.7.1 비교 조건의 종류와 효율성

다중 컬럼 인덱스에서 컬럼 순서와 컬럼에 사용된 조건이 동등 비교인지 크다 또는 작다의 부등호인지에 따라 활용 형태가 달라지고 효율이 달라진다.

```mysql
SELECT * FROM dept_emp
WHERE dept_no='d002' AND emp_no >= 10114;
```

이 쿼리를 위해 dept_emp 테이블에 각각 컬럼의 순서만 다른 두 가지 케이스로 인덱스를 생성했다고 가정하자.

- case A: INDEX (dept_no, emp_no)
- case B: INDEX (emp_no, dept_no)

case A는 WHERE 절의 레코드를 찾고 이후에 dept_no가 d002가 아닐때까지 인덱스를 그냥 쭉 읽기만 하면 된다. -> 효율적

case B는 dept_no='d002' AND emp_no >= 10114 레코드를 찾고 이후 모든 레코드에 대해 d002인지 비교하는 과정을 거쳐야 한다.

이처럼 인덱스를 토앻 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 '필터링'이라고도 한다.

공식명칭은 아니지만 dept_no='d002' AND emp_no >= 10114과 같이 작업의 범위를 결정하는 조건을 '작업 범위 결정 조건'이라 하고, 케이스 B 인덱스의 dept_no='d002' 조건과 같이 비교 작업의 범위를 줄이지 못하고 단순 거름종이 역할만 하는 조건을 '필터링 조건' 또는 '체크 조건'이라 표현한다.

즉, case A는 '작업 범위 결정 조건'에 해당하고 case B는 emp_no만 '작업 범위 결정 조건'이고 dept_no는 '필터링 조건'으로 사용된 것이다.

### 8.3.7.2 인덱스의 가용성

B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬돼 있다는 것이다.  
여기서 왼쪽이란 하나의 컬럼뿐 아니라 다중 컬럼 인덱스의 컬럼에 대해서도 함께 적용된다.

- case A: INDEX (first_name)
- case B: INDEX (dept_no, emp_no)

```mysql
SELECT * FROM employees WHERE first_name LIKE '%mer';
```

이 쿼리는 레인지 스캔으로 이용할 수 없다.  그 이유는 first_name 컬럼에 저장된 값의 왼쪽부터 한 글자씩 비교해 가면서 일치하는 레코드를 찾아야 하는데, 조건절에 주어진 상숫값에는 왼쪽 부분이 고정되지 않았기 때문이다. B-tree 인덱스의 효과도 얻을 수 없다.

```mysql
SELECT * FROM dept_emp WHERE emp_no >= 10144;
```

dept, emp 순으로 정렬되므로 이 쿼리도 dept 없인 효율적으로 사용할 수 없다.

### 8.3.7.3 가용성과 효율성 판단

아래 조건들은 작업 범위 결정 조건으로 사용할 수 없다.
경우에 따라 체크 조건으로 인덱스를 사용할 수는 있다.

```text
<>
NOT IN
NOT BETWEEN
IS NOT NULL
LIKE '%??'
SUBSTRING
DAYOFMONTH
deterministic_function()
데이터 타입이 서로 다른 비교
문자열 데이터 타입의 collation이 다른 경우
```

MySQL에서는 NULL 값도 인덱스에 저장된다.

```mysql
INDEX ix_test (col1, col2, col3 ,,, colN)
```

- 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
  - col1 조건이 없는 경우
  - col1 비교 조건이 위 인덱스 사용 불가 조건 중 하나인 경우
- 작업 범위 결정 조건으로 인덱스를 사용하는 경우
  - col1 ~ colN-1 컬럼까지 = 또는 IN 비교인 경우
  - 동등비교, 크다작다, LIKE 좌측일치패턴

