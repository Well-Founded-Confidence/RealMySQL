# 8.2 인덱스란?

DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다.

SELECT 쿼리 문장의 WHERE 조건절에 사용되는 컬럼이라고 해서 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과만 불러올 수 있다.

- PK는 식별자라고도 부르며, NULL 값과 중복 값을 허용하지 않는다.
- PK를 제외한 나머지 모든 인덱스는 세컨더리 인덱스라고 부른다. 유티크 인덱스는 PK와 성격이 비슷하고 PK를 대체해서 사용할 수도 있다고 해서 `대체 키`라고도 한다.

데이터 저장 방식별로 구분하는 경우 대표적으로 B-Tree INDEX, HASH INDEX로 구분할 수 있다.

최근엔 Fractal-Tree 인덱스나 로그 기반의 Merge-Tree 인덱스와 같은 알고리즘을 사용하는 DBMS도 개발되고 있다.

### B-Tree 인덱스

- B-Tree 인덱스는 가장 일반적으로 사용되는 인덱스 알고리즘이다. 가장 오래되었고, 그만큼 가장 성숙해진 상태다.
- 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.
- MySQL 서버에서는 위치 기반 검색을 지원하기 위한 R-Tree 인덱스 알고리즘도 있지만, 결국 R-Tree 인덱스는 B-Tree의 응용 알고리즘으로 볼 수 있다.

### Hash 인덱스

- 컬럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다.
- 하지만 값을 변형하여 인덱싱하므로 전방(Prefix) 일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없다.
- Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

인덱스가 유니크한지 아닌지는 단순히 같은 값이 1개만 존재하는지 1개 이상 존재할 수 있는지를 의미하지만,
실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 상당히 중요한 문제가 된다.
유니크 인덱스에 대해 동등 조건(Equal)으로 검색한다는 것은 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다.
