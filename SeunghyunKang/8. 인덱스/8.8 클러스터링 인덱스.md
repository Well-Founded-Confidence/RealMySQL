# 8.8 클러스터링 인덱스

> 클러스터링이란 여러 개를 하나로 묶는다는 의미로 사용된다.

MySQL에서 클러스터링은 테이블의 레코드를 비슷한 것(PK 기준)들끼리 묶어서 저장하는 형태로 구현된다. (InnoDB 에서만 지원)

## 8.8.1 클러스터링 인덱스

PK 값에 의해 레코드 저장 위치가 결정된다.

PK가 변경되면 그 물리적 저장 위치가 바뀌어야 한다는 것을 의미한다.

PK 값으로 클러스터링된 테이블은 PK 값 자체에 대한 의존도가 상당히 크기 떄문에 신중히 PK를 결정해야 한다.

> 클러스터링 인덱스와 클러스터링 테이블은 동의어로 사용되기도 한다.

항상 클러스터링 인덱스로 저장되는 테이블은 PK 기반의 검색이 매우 빠르나, 레코드의 저장이나 PK의 변경이 상대적으로 느리다.

![8.25 클러스터링 테이블(인덱스) 구조](../resources/8.25%20클러스터링%20테이블(인덱스)%20구조.png)

일반 B-Tree와 비슷하지만 세컨더리 인덱스를 위한 B-Tree의 리프 노드와는 달리 클러스터링 인덱스의 리프 노드에는 레코드의 모든 컬럼이 같이 저장돼 있음을 알 수 있다.

즉, 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리되는 것이다.

아래 쿼리를 실행해보자

```mysql
UPDATE tb_test SET emp_n=10002 WHERE emp_no=10007;
```

그림 8.25에서는 10007인 레코드는 3번 페이지에 저장되어있는데, 쿼리를 실행하면 10002로 변경되면서 2번 페이지로 이동하게 된다.

> 그렇다면 PK가 없는 테이블은 어떻게 클러스터링 테이블로 구성될까

PK가 없는 테이블은 다음 우선순위대로 PK를 대체할 컬럼을 선택한다.

1. PK가 있으면 기본적으로 PK를 클러스터링 키로 선택
2. NOT NULL 옵션의 유니크 인덱스 중 첫 번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후 클러스터링 키로 선택

자동으로 추가된 컬럼은 사용자에게 노출되지 않고 명시적으로 사용할 수 없다.

즉, PK나 유니크 인덱스가 없는 테이블은 아무 의미 없는 숫자 값으로 클러스터링 되고 아무런 혜택이 없다.

## 8.8.2 세컨더리 인덱스에 미치는 영향

클러스터링 키 값이 변경될 때마다 레코드 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 한다.

이런 오버헤드를 제거하기 위해 InnoDB의 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 PK 값을 저장하도록 구현돼 있다.

```mysql
CREAT TABLE employees (
  emp_no INT NOT NULL,
  first_name VARCHAR(20) NOT NULL,
  PRIMARY KEY (emp_no),
  INDEX ix_firstname (firstname)
);
```

- MyISAM: ix_firstname 인덱스를 검색해서 레코드의 주소 확인 후 레코드 주소를 이용해 최종 레코드를 가져옴
- InnoDB: ix_firstname 인덱스를 검색해 레코드의 PK 값을 확인 후, PK 인덱스를 검색해서 최종 레코드를 가져옴

## 8.8.3 클러스터링 인덱스의 장점과 단점

- 장점
  - PK로 검색할 때 처리 성능이 매우 빠름(특히 PK 범위 검색)
  - 테이블의 모든 세컨더리 인덱스가 PK를 가지고 있기에 인덱스만으로 처리될 수 있는 경우가 많음(커버링 인덱스)
- 단점
  - 모든 세컨더리 인덱스가 클러스터링 키를 갖기에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
  - 세컨더리 인덱스를 통해 검색할 때 PK로 다시 한번 검색해야 하므로 처리 성능이 느림
  - INSERT 할 떄 PK에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
  - PK를 변경할 때 레코드를 DELETE 하고 INSERT하는 작업이 필요하기에 처리 성능이 느림

즉, 빠른 읽기, 느릭 쓰기이다.일반적인 OLTP(Online Transaction Processing)에서는 쓰기 읽기 비율이 2:8 ~ 1:9이기에 빠른 읽기가 중요하다.

## 8.8.4 클러스터링 테이블 사용 시 주의사항

### 8.8.4.1 클러스터링 인덱스 키의 크기

클러스터링 테이블의 경우 모든 세컨더리 인덱스가 PK 값을 포함한다.  
그래서 PK 크기가 커지면 세컨더리 인덱스도 자동으로 크기가 커진다.

세컨더리 인덱스가 4~5개 정도 생성된다는 것을 고려하면 세컨더리 인덱스 크기는 급격히 증가한다.

|PK 크기|레코드당 증가하는 인덱스 크기|100만 건 레코드 저장 시 증가하는 인덱스 크기|
|---|---|---|
|10바이트|10바이트 * 5 = 50바이트|50바이트 * 1,000,000 = 47MB|
|50바이트|50바이트 * 5 = 250바이트|250바이트 * 1,000,000 = 238MB|

1000만 건이 되면 1.9GB가 증가한다. 또한 성능을 내기 위해 그만큼의 메모리가 더 필요하기에 PK는 신중하게 선택해야 한다.

### 8.8.4.2 PK는 AUTO-INCREMENT 보다는 업무적인 컬럼으로 생성

컬럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 컬럼을 PK로 설정하는 것이 좋다.

### 8.8.4.3 PK는 반드시 명시할 것

가능하면 AUTO_INCREMENT 컬럼을 이용해서라도 PK는 생성하는 것을 권장한다.

PK를 설정하지 않으면 내부적으로 일련번호 컬럼을 추가하지만 사용자가 이용할 수 없다.

또한 ROW 기반의 복제나 InnoDB Cluster에서는 모든 테이블이 PK를 가져야만 하는 정상적인 복제 성능을 보장하기도 하므로 PK는 꼭 생성하자

### 8.8.4.4 AUTO-INCREMENT 컬럼을 인조 식별자로 사용할 경우

세컨더리 인덱스도 필요하고 PK 크기도 길다면 AUTO_INCREMENT 컬럼을 추가하고 이를 PK로 설정하면 된다.

이렇게 프라이머리 키를 대체하기 위해 인위적으로 추가된 PK를 인조 식별자(Surrogate key)라고 한다.
