# 5.3 InnoDB 스토리지 엔진 잠금

InnoDB 스토리지 엔진에서 잠금에 대한 정보를 보는 도구(잠금 정보 진단)는 lock_monitor와 SHOW ENGINE INNODB STATUS 명령이 전부였다.

하지만 이 내용도 거의 어셈블리 코드를 보는 것 같아서 상당히 어려웠다.

최근 버전에서는 InnoDB의 트랜잭션과 잠금, 잠금 대기 중인 트랜잭션의 목록을 조회할 수 있는 방법이 도입됐다.

information_schema DB의 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS라는 테이블을 조회하면 어떤 트랜잭션이 어떤 잠금을 대기하고 있고 해당 잠금을 어느 트랜잭션이 가지고 있는지 확인할 수 있다.

## 5.3.1 InnoDB 스토리지 엔진의 잠금

InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간을 관리된다.

때문에, 레코드 락이 페이지락이나 테이블락으로 레벨업(락 에스컬레이션)되는 경우는 없다.

대신 레코드와 레코드 사이 간격을 잠그는 GAP LOCK이 존재한다.

<img src="../resources/5.1%20InnoDB%20잠금의%20종류.png" alt="InnoDB 잠금의 종류" style="zoom:60%;" />

### 5.3.1.1 레코드 락

레코드 자체만을 잠그는 것이다.

하지만 InnoDB는 레코드 자체가 아니라 인덱스의 레코드를 잠근다.  

<u>**인덱스가 하나도 없는 테이블이더라도, 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.**</u>

### 5.3.1.2 갭 락

레코드와 레코드 사이의 간격에 새로운 레코드가 INSERT 되는 것을 제어하는 것이다.

넥스트 키 락의 일부로 자주 사용된다.

### 5.3.1.3 넥스트 키 락

레코드 락과 갭 락을 합쳐 놓은 형태의 잠금이다.

binlog를 사용하는 MySQL 서버에서는 REAPEATABLE READ 격리 수준을 사용해야 한다.

또한, `innodb_locks_unsafe_for_binlog` 시스템 변수가 비활성화되면 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸린다.

> 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적.

그런데, <u>**넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다.**</u>

가능하면 바이너리 로그 포맷을 row 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.

> 그래서 binlog랑 넥스트 키 락이랑 무슨 관계라는걸까?

> MySQL 8.0부터는 바이너리 로그의 기본 포맷이 row로 변경되었다.

### 5.3.1.4 자동 증가 락

AUTO_INCREMENT다.

동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 값을 가져야 한다.

<u>**내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금을 사용한다.**</u>

이는, 트랜잭션과 관계 없이 INSERT나 REPLACE에서 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다.

그리고 테이블에 단 하나만 존재하며, 명시적으로 획득하고 해제하는 방법은 없다.

하지만 여기까진 5.0 이하 버전에서의 방식이고, 5.1 이상부터는 innodb_autoinc_lock_mode라는 시스템 변수를 이용해 자동 증가 락의 작동 방식을 변경할 수 있따.

- innodb_autoinc_lock_mode=0
  5.0과 동일한 잠금 방식이다

- innodb_autoinc_lock mode=1
  INSERT 되는 레코드의 건수를 정확히 예측할 수 있을 때는 자동 증가 락을 사용하지 않고, 훨씬 가볍고 빠른 래치(뮤텍스)를 이용해 처리한다.
  하지만, INSERT ,,, SLECT 처럼 건수를 모를때는 5.0과 같이 자동 증가 락을 사용한다.

- innodb_autoinc_lock_mode=2
  절대 자동 증가 락을 걸지 않고 래치를 사용한다.
  INSERT ... SELECT 처럼 대량 INSERT 문장이 실행되는 중에도 다른 커넥션에서 INSERT를 수행할 수 있다. (인터리빙모드로 연속된 증가 값을 보장하지 않음)
  STATEMENT 포맷의 바이너리 로그를 사용하는 복제에서는 소스 서버와 레플리카 버서의 자동 증가 값이 달라질 수 있기에 유의해야 한다.

> 기본값이 5.7까지는 1이었고, 8.0부터는 2로 바뀌었다.  
이는 8.0부터 바이너리 로그 포맷이 ROW로 바뀌었기 때문이다.

## 5.3.2 인덱스와 잠금

특정 필드에 대해 where 절로 검색을 할 때 index가 걸려있지 않은 테이블에 대해 찾고, 1개 ROW에 대해 UPDATE를 하더라도, 모든 테이블에 락이 걸린다.

그렇기에 InnoDB에서 인덱스 설계가 중요하다.

## 5.3.3 레코드 수준의 잠금 확인 및 해제

테이블이 통째로 잠금에 걸리면 문제 원인이 쉽게 발견되고 해결할 수 있다.  
하지만, 레코드 수준인 경우, 그리고 자주 사용되지 않는다면 이 문제를 찾기가 힘들 수 있다.

