# 9.2 기본 데이터 처리

결과물은 동일해도 그 결과를 만들어 내는 과정은 천차만별이다.

## 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

MySQL 옵티마이저는 다음과 같은 조건에서 풀 테이블 스캔을 선택한다.

- 테이블 레코드 건수가 작아서 인덱스를 통해 읽는 것보다 풀테이블 스캔을 하는 편이 더 빠른 경우(일반적으로 테이블이 페이지 1개로 구성된 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우

InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.

리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예츠갷서 요청이 오기 전에 미리 디스크에서 읽어 버퍼 풀에 가져다 두는 것을 의미한다.

즉, 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부image.png터는 읽기 작업을 백그라운드 스레드로 넘긴다.

백그라운드 스레드가 읽기를 넘겨받는 시점부터 한 번에 4 또는 8개의 페이지를 읽으며 그 수를 증가시키고, 최대 64개의 데이터 페이지까지 읽어 버퍼 풀에 저장해 둔다.

포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨리 처리되는 것이다.

```mysql
SELECT count(*) FROM employees;
```

위 쿼리를 실행하면 풀 테이블 스캔을 할 것 같지만 실제 실행 계획은 풀 인덱스 스캔을 하게 될 가능성이 높다.  
모든 컬럼 정보가 필요 없기 때문에 인덱스의 컬럼만으로 훨씬 빠른 처리가 되기 때문이다.

```mysql
SELECT * FROM employees;
```

하지만 위와 같은 쿼리는 풀 인덱스 스캔을 활용하지 못하고 풀 테이블 스캔을 한다.


## 9.2.2 병렬 처리

`innodb_parallel_read_threads`라는 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지 변경할 수 있다.

수를 점점 늘리면 쿼리 실행 시간이 줄어드는 것을 볼 수 있으나, CPU 코어 개수를 넘어가면 더 느려지는 경우도 발생한다.

### 9.2.3 ORDER BY 처리(Using filesort)

||장점|단점|
|---|---|---|
|인덱스 이용|INSERT UPDATE DELETE 실행될 때 이미 인덱스가 정렬돼 있어 순서대로 읽기만 하면 되므로 매우 빠름|부가적인 인덱스 추가/삭제 작업이 필요하므로 느림. 인덱스도 결국 저장되는 데이터니 추가 공간 필요함. 개수가 늘어날수록 버퍼 풀을 위한 메모리가 많이 필요함|
|Filesort 이용|레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠름|정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리 응답 속도가 느림|

모든 정렬을 인덱스를 이용하도록 튜닝하기란 거의 불가능하다

- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

인덱스를 수행하지 않고 별도 정렬 처리를 했는지 확인하려면 실행 계획의 Extra 컬럼에 Using filesort 메시지 표시로 알 수 있다.

### 9.2.3.1 소트 버퍼

정렬 수행을 위해 별도 메모리 공간을 할당받아 사용하는데, 이 메모리 공간을 소트 버퍼라고 한다.

정렬이 필요한 경우에만 할당되고 버퍼 크기는 정렬해야 할 레코드 크기에 따라 가변적으로 증가하지만 최대 공간은 `sort_buffer_size`라는 시스템 변수로 설정할 수 있다.

소트 버퍼를 위한 메모리 공간은 쿼리 실행이 완료되면 즉시 시스템으로 반납된다.

정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면 어떻게될까?
MySQL은 정렬해야 할 레코드를 여러 조각으로 나눠 처리하는데 이 과정에서 임시 저장을 위해 디스크를 사용한다.

소트 버퍼에서 정렬 수행하고 임시로 디스크에 기록하고 레코드를 가져와 다시 정렬하고 반복적으로 디스크에 임시 저장한다.

이 병합 작업을 멀티 머지라고 표현한다.

정렬을 위해 할당하는 **소트 버퍼는 세션 메모리 영역에 해당**한다.
> 즉, 소트 버퍼는 **여러 클라이언트가 공유해서 사용할 수 있는 영역이 아니다.** 커넥션이 많을수록, 정렬 작업이 많을수록 소트 버퍼로 소비되는 공간이 커짐을 의미한다.

더 이상 메모리 여유 공간이 없을때 OS의 OOM-Killer가 메모리를 가장 많이 사용하는 프로세스를 강제 종료한다.
메모리를 가장 많이 사용하는 프로세스는 보통 MySQL 서버다.

### 9.2.3.2 정렬 알고리즘

