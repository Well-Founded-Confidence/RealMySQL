[8.8 클러스터링 인덱스](#88-클러스터링-인덱스)
- [8.8.1 클러스터링 인덱스](#881-클러스터링-인덱스)
    - [PK가 없는 InnoDB 테이블](#pk가-없는-innodb-테이블)
- [8.8.2 세컨더리 인덱스에 미치는 영향](#882-세컨더리-인덱스에-미치는-영향)
- [8.8.3 클러스터링 인덱스의 장점과 단점](#883-클러스터링-인덱스의-장점과-단점)
- [8.8.4 클러스터링 테이블 사용 시 주의사항](#884-클러스터링-테이블-사용-시-주의사항)
    - [8.8.4.1 클러스터링 인덱스 키의 크기](#8841-클러스터링-인덱스-키의-크기)
    - [8.8.4.2 PK는 AUTO_INCREMENT보다는 업무적인 컬럼으로 생성](#8842-pk는-auto_increment보다는-업무적인-컬럼으로-생성)
    - [8.8.4.3 PK는 반드시 명시할 것](#8843-pk는-반드시-명시할-것)
    - [8.8.4.4 AUTO_INCREMENT 칼럼을 인조 식별자로 사용할 경우](#8844-auto_increment-칼럼을-인조-식별자로-사용할-경우)

# 8.8 클러스터링 인덱스
- 클러스터링: 여러 개를 하나로 묶는다
- MySQL 서버에서 테이블의 레코드를 비슷한 것들끼리 묶어서 저장하는 형태로 구현된다.
    - 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안한 것
- InnoDB 스토리지 엔진에서만 지원한다.

## 8.8.1 클러스터링 인덱스
- PK에만 적용되며, PK 값이 비슷한 레코드끼리 묶어서 저장한다.
    - PK 값에 의해 레코드의 저장 위치가 결정된다.
    - PK 값이 변경된다면 레코드의 물리적인 저장 위치가 변경돼야 한다.
    - PK 값에 대한 의존도가 크기 때문에 신중히 PK를 선정하도록 한다.
- 일반적으로 InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 PK 기반의 검색이 매우 빠르고, 레코드의 저장이나 PK의 변경이 상대적으로 느리다.

![img](./img/8.25%20%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81%20%ED%85%8C%EC%9D%B4%EB%B8%94%20%EA%B5%AC%EC%A1%B0.png)
- 클러스터링 테이블의 구조 자체는 일반 B-Tree와 비슷하다.
- 세컨더리 인덱스를 위한 B-Tree의 리프노드와는 달리 레코드의 모든 칼럼이 같이 저장되어 있다.
- 레코드 자체가 하나의 거대한 인덱스 구조로 관리된다.

### PK가 없는 InnoDB 테이블
- PK가 없는 경우에는 InnoDB 스토리지 엔진이 다음 우선순위대로 PK를 대체할 칼럼을 선택한다.
1. PK가 있으면 PK를 클러스터링 키로 선택
2. NOT NULL 옵션의 유니크 인덱스중에서 첫번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후 클러스터링 키로 선택

## 8.8.2 세컨더리 인덱스에 미치는 영향
- InnoDB 테이블에서 세컨더리 인덱스가 실제 레코드가 저장된 주소를 가지고 있다면
    - 클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고, 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 할 것이다.
    - 이런 오버헤드를 제거하기 위해 InnoDB 테이블의 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 PK 값을 저장하도록 구현되어 있다.

## 8.8.3 클러스터링 인덱스의 장점과 단점
- 장점
    - PK로 검색할 때 처리 성능이 매우 빠름 (PK를 범위 검색하는 경우 매우 빠름)
    - 테이블의 모든 세컨더리 인덱스가 PK를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음 (커버링 인덱스)
- 단점
    - 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
    - 세컨더리 인덱스를 통해 검색할 때 PK로 다시 한번 검색해야하므로 처리 성능이 느림
    - INSERT할 때 PK에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
    - PK를 변경할 때 레코드를 DELETE하고 INSERT 하는 작업이 필요하기 때문에 처리 성능이 느림

## 8.8.4 클러스터링 테이블 사용 시 주의사항
### 8.8.4.1 클러스터링 인덱스 키의 크기
- 클러스터링 테이블의 경우 모든 세컨더리 인덱스가 PK를 포함한다.
    - PK의 크기가 커지면 세컨더리 인덱스도 커진다.
- 일반적으로 테이블에 세컨더리 인덱스가 4 ~ 5개 정도 생성된다는 것을 고려하면 세컨더리 인덱스의 크기는 급격히 증가한다.
- 인덱스가 커질수록 같은 성능을 내기 위해 그만큼의 메모리가 더 필요

### 8.8.4.2 PK는 AUTO_INCREMENT보다는 업무적인 컬럼으로 생성
- PK는 클러스터링 키로 사용되며, 이 값에 의해 레코드의 위치가 결정된다.
- PK로 검색하는 경우 클러스터링되지 않은 테이블에 비해 매우 빠르게 처리될 수 있다.
- PK는 의미 만큼이나 중요하기 때문에 대부분 검색에서 상당히 빈번하게 사용되는 것이 일반적이다.
- 칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 칼럼을 PK로 설정한다.

### 8.8.4.3 PK는 반드시 명시할 것
- AUTO_INCREMENT를 사용하더라도 PK는 되도록 생성하는 것이 좋다.
- InnoDB 테이블에서 PK를 정의하지 않으면 InnoDB 스토리지 엔진이 내부적으로 일련번호 칼럼을 추가한다.
- ROW 기반의 복제나 InnoDB Cluster에서는 모든 테이블이 PK를 가져야만 하는 정상적인 복제 성능을 보장하기도 한다.

### 8.8.4.4 AUTO_INCREMENT 칼럼을 인조 식별자로 사용할 경우
- 여러 개의 칼럼이 복합으로 PK가 만들어지거나 PK의 크기가 길어져도 세컨더리 인덱스가 필요치 않다면 그대로 PK를 사용하는 것이 좋다.
- 세컨더리 인덱스도 필요하고, PK의 크기도 길어진다면 AUTO_INCREMENT 칼럼을 추가한다.
    - PK를 대체하기 위해 인위적으로 추가된 PK를 인조 식별자라고 한다.
    - 로그 테이블과 같이 조회보다는 INSERT 위주의 테이블들은 AUTO_INCREMENT를 이용한 인조 식별자롤 PK로 설정하는 것이 성능 향상에 도움이 된다.
