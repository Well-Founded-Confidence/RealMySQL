[10.3 실행 계획 분석](#103-실행-계획-분석)
- [10.3.1 id 컬럼](#1031-id-컬럼)
- [10.3.2 select_type 컬럼](#1032-select_type-컬럼)
- [10.3.3 table 컬럼](#1033-table-컬럼)
- [10.3.4 partitions 컬럼](#1034-partitions-컬럼)
- [10.3.5 type 컬럼](#1035-type-컬럼)
- [10.3.6 possible_keys 컬럼](#1036-possible_keys-컬럼)
- [10.3.7 key 컬럼](#1037-key-컬럼)
- [10.3.8 key_len 컬럼](#1038-key_len-컬럼)
- [10.3.9 ref 컬럼](#1039-ref-컬럼)
- [10.3.10 rows 컬럼](#10310-rows-컬럼)

# 10.3 실행 계획 분석
- MySQL 8.0부터 실행 계획의 포맷을 `테이블` `JSON` `TREE` 형태로 선택할 수 있다.
- 실행 계획이 어떤 접근 방법을 사용해서 어떤 최적화를 수행하는지, 어떤 인덱스를 사용하는지 등을 이해하는 것이 중요하다.

## 10.3.1 id 컬럼
- 단위 SELECT 쿼리별로 부여되는 식별자 값
  - 하나의 SELECT 문장에 여러개의 테이블을 조인하면 테이블의 갯수만큼 실행 계획 레코드가 출력되지만 id 값은 같다.
    ![img](./img/id1.png)
  - 쿼리 문장이 여러개의 단위 SELECT 쿼리로 구성되어 있으면 다른 id 값을 부여한다.
    ![img](./img/id2.png)

## 10.3.2 select_type 컬럼
- 각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼

### 10.3.2.1 SIMPLE
- UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT
- 실행 계획에서 하나만 존재하고, 일반적으로 제일 바깥 SELECT 쿼리가 해당

### 10.3.2.2 PRIMARY
- UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리는 PRIMARY로 표시된다.
- 실행 계획에서 하나만 존재하고, 제일 바깥쪽의 SELECT 쿼리가 해당

### 10.3.2.3 UNION
- UNION으로 결합하는 단위 SELECT 쿼리 중 첫 번째를 제외한 SELECT
  - 첫 번째 SELECT는 UNION되는 쿼리 결과들을 모아서 저장하는 임시 테이블 (DERIVED)으로 표시

### 10.3.2.4 DEPENDENT UNION
- UNION or UNION ALL로 집합을 결합하는 쿼리에서 표시
- DEPENDENT는 UNION or UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미
```sql
  EXPLAIN
    SELECT *
    FROM employees e1 WHERE e1.emp_no IN (
      SELECT e2.emp_no FROM employees e2 WHERE e2.first_name='Matt'
      UNION
      SELECT e3.emp_no FROM employees e3 WHERE e3.last_name='Matt'
    );
```
- 외부의 employees 테이블을 먼저 읽은 다음 서브쿼리를 실행한다.
  - 이때 employees 테이블의 컬럼 값이 서브쿼리에 영향을 준다.

### 10.3.2.5 UNION RESULT
- UNION 결과를 담아두는 테이블
- MySQL 8.0 이전에는 UNION UNION ALL 모두 임시 테이블로 생성했다.
- MySQL 8.0버전부터 UNION ALL은 임시 테이블을 사용하지 않도록 개선되었다.
  - UNION은 여전히 임시 테이블에 결과를 버퍼링한다.
- 실제 쿼리에서 단위 쿼리가 아니기 때문에 id가 부여되지 않는다.
```sql
  EXPLAIN
    SELECT emp_no FROM salaries WHERE salary>100000
    UNION DISTINCT
    SELECT emp_no FROM dept_emp WHERE from_date>'2001-01-01';
```
![img](./img/union_result.png)
- table 컬럼의 `<union1,2>`는 id가 1, 2인 쿼리 결과를 union했다는 것을 의미한다.

### 10.3.2.6 SUBQUERY
- FROM절 이외에서 사용되는 서브쿼리만 해당
- FROM절에 사용된 서브쿼리는 DERIVED로 표시된다.

### 10.3.2.7 DEPENDENT SUBQUERY
- 서브쿼리가 바깥쪽 SELECT 쿼리에서 정의된 컬럼을 사용하는 경우 표시된다.
```sql
  EXPLAIN
    SELECT e.first_name,
      ( SELECT COUNT(*)
        FROM dept_emp de, dept_manager dm
        WHERE dm.dept_no=de.dept_no AND de.emp_no=e.emp_no ) AS cnt
    FROM employees e
    WHERE e.first_name='Matt';
```
![img](./img/dependent_subquery.png)
- 외부 쿼리가 먼저 수행된 후 내부 쿼리가 실행돼야 하므로 일반 서브쿼리보다는 처리 속도가 느릴 때가 많다.

### 10.3.2.8 DERIVED
- 단위 SELECT 쿼리릐 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미
- DERIVED일 때 생성되는 임시 테이블을 파생 테이블이라고도 한다.
- ~ MySQL 5.5
  - 서브쿼리가 FROM절에 사용되면 select_type은 항상 DERIVED이었다.
  - 임시 테이블에는 인덱스가 없으므로 다른 테이블과 조인할때 성능상 불리할 때가 많다.
- MySQL 5.6 ~
  - 옵티마이저 옵션에 따라 FROM절의 서브쿼리를 외부 쿼리와 통합하는 형태의 최적화가 수행되기도 한다.
  - 임시 테이블에도 인덱스를 추가해서 만들 수 있게 최적화되었다.
- MySQL 8.0 부터는 FROM절의 서브쿼리에 대한 최적화도 많이 개선되어 가능하다면 불필요한 서브쿼리는 조인으로 쿼리를 재작성해서 처리한다.
  - 옵티마이저가 처리할 수 있는 것은 한계가 있으므로 최적화된 쿼리를 작성하는 것은 중요하다.

### 10.3.2.9 DEPENDENT DERIVED
- MySQL 8.0 이전에는 FROM 절의 서브쿼리는 외부 컬럼을 사용할 수 없었다.
- MySQL 8.0 부터는 레터럴 조인 기능이 추가되어 FROM절의 서브쿼리에서도 외부 컬럼을 참조할 수 있게 되었다.
```sql
  SELECT *
  FROM employees e
  LEFT JOIN LATERAL
    ( SELECT *
      FROM salaries s
      WHERE s.emp_no=e.emp_no
      ORDER BY s.from_date DESC LIMIT 2 ) AS s2
    ON s2.emp_no=e.emp_no;
```
![img](./img/dependent_derived.png)
- LATERAL 키워드를 사용해야 하며, 사용하지 않고 외부 컬럼을 참조하면 오류가 발생한다.

### 10.3.2.10 UNCACHEABLE SUBQUERY
- 서브쿼리에 포함된 요소에 의해 캐시가 불가능한 쿼리
- 조건이 똑같은 서브쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 그대로 사용할 수 있도록 내부적인 캐시 공간에 담는다.
  - 쿼리 캐시나 파생 테이블과는 다른 기능

![img](./img/10.4%20SUBQUERY의%20결과%20캐시.png)
- SUBQUERY는 바깥쪽의 영향을 받지 않으므로 처음 한 번만 실행해서 그 결과를 캐시하고 필요할 때 캐시된 결과를 이용한다.
- DEPENDENT SUBQUERY는 의존하는 바깥쪽 쿼리의 컬럼의 값 단위로 캐시해두고 사용한다.

#### SUBQUERY vs UNCACHEABLE SUBQUERY
캐시를 사용할 수 있냐 없냐의 차이가 있다.
캐시를 사용 못하는 경우
- 사용자 변수가 서브쿼리에 사용된 경우
- NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우
- UUID, RAND와 같이 결괏값이 호출할 때마다 달라지는 함수가 서브쿼리에 사용된 경우

### 10.3.2.11 UNCACHEABLE UNION
- union을 사용하는 쿼리의 요소에 의해 캐시가 불가능한 경우

### 10.3.2.12 MATERIALIZED
- FROM절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용된다.
```sql
  EXPLAIN
    SELECT *
    FROM employees e
    WHERE e.emp_no IN ( SELECT emp_no FROM salaries WHERE salary BETWEEN 100 AND 1000 );
```
![img](./img/materialized.png)
- MySQL 5.6 까지는 employees 테이블을 읽어서 레코드마다 서브쿼리가 실행되는 형태로 처리되었다.
- MySQL 5.7 부터는 서브쿼리의 내용을 임시 테이블로 구체화한 후 임시 테이블과 employees 테이블을 조인하는 형태로 최적화되어 처리된다.

## 10.3.3 table 컬럼
- 실행 계획은 테이블 기준으로 표시된다.
- 테이블의 이름에 별칭이 부여된 경우에는 별칭이 표시된다.
```sql
  EXPLAIN SELECT NOW();
  EXPLAIN SELECT NOW() FROM DUAL;
```
![img](./img/no_table.png)
- 첫 번째 쿼리는 FROM절 자체가 없다.
- 두 번째 쿼리는 실제로는 없는 DUAL 테이블을 사용한다.
  - 오류를 발생시키지는 않고 테이블이 있는것처럼 작동한다.
  - MySQL 옵티마이저는 FROM DUAL 부분을 제거하고 첫 번째 쿼리와 동일하게 변형시켜서 처리한다.
- 둘다 table 컬럼에 NULL이 표시된다.

![img](./img/table.png)
- `<>`가 사용된 이름은 임시 테이블을 의미한다.
  - `<>` 내에 표시되는 숫자는 SELECT 쿼리의 id 값을 가리킨다.
- id=2인 쿼리가 먼저 실행되어 결과가 파생 테이블로 저장되었고, 생성된 파생 테이블과 e 테이블이 조인되는 쿼리임을 알 수 있다.
- id=1인 쿼리 중 먼저 표시된 <derived2> 테이블이 드라이빙 테이블이 되고, e 테이블이 드리븐 테이블이 된다.

## 10.3.4 partitions 컬럼
- MySQL 5.7 까지는 옵티마이저가 사용하는 파티션들의 목록은 EXPLAIN PARTITION 명령으로 확인이 가능했다.
- MySQL 8.0 부터는 EXPLAIN 명령으로 파티션 관련 실행 계획까지 모두 확인할 수 있다.

```sql
  -- 파티션 테이블 생성
  CREATE TABLE employees_2 (
    emp_no int NOT NULL,
    birth_date DATE NOT NULL,
    first_name VARCHAR(14) NOT NULL,
    last_name VARCHAR(16) NOT NULL,
    gender ENUM('M', 'F') NOT NULL,
    hire_date DATE NOT NULL,
    PRIMARY KEY (emp_no, hire_date)
  ) PARTITION BY RANGE COLUMNS(hire_date)
  (PARTITION p1986_1990 VALUES LESS THAN ('1990-01-01'),
  PARTITION p1991_1995 VALUES LESS THAN ('1996-01-01'),
  PARTITION p1996_2000 VALUES LESS THAN ('2000-01-01'),
  PARTITION p2001_1995 VALUES LESS THAN ('2006-01-01'));

  INSERT INTO employees_2 SELECT * FROM employees;
```
```sql
  EXPLAIN
    SELECT *
    FROM employees_2
    WHERE hire_date BETWEEN '1999-11-15' AND '2000-01-15';
```
![img](./img/partition.png)
- 위 쿼리에서 조회할 데이터는 p1996_2000, p2001_2005 파티션에 저장되어 있음을 알 수 있다.
- 옵티마이저는 쿼리의 hire_date 컬럼 조건을 확인하고, 필요로 하는 파티션을 알아낸다.
  - 나머지 파티션에 대해서는 분석을 하지 않음
- 파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근할 테이블만 골라내는 과정을 `파티션 프루닝`이라고 한다.
- type 컬럼의 값이 ALL인 것은 풀 테이블 스캔으로 쿼리가 처리되었다는 것을 의미한다.
  - MySQL을 포함한 대부분의 RDBMS에서 지원하는 파티션은 물리적으로 개별 테이블처럼 별도의 저장 공간을 가지기 때문이다.
  - 따라서 조회 대상인 p1996_2000, p2001_2005 파티션에 대해서만 풀 스캔을 진행한다.

## 10.3.5 type 컬럼
- MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.
  - 레코드를 읽을 때 인덱스를 사용했는지, 풀 테이블 스캔을 사용했는지 등
  - 쿼리를 튜닝할 때 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로 반드시 체크해야 할 정보
- 아래 소제목들은 일반적으로 성능이 빠른 순서
  - 실제로 데이터의 분포나 레코드의 건수에 따라 달라질 수는 있음

### 10.3.5.1 system
> 레코드가 1건 이하로 존재하는 테이블을 참조하는 형태의 접근방법

- MyISAM이나 MEMORY 테이블에서만 사용되는 접근 방법

### 10.3.5.2 const
> 테이블의 레코드 건수와 관계없이 쿼리가 PK나 유니크 키 컬럼을 이용하는 where 조건절을 갖고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식

![img](./img/const1.png)
- 유니크 인덱스 스캔이라고도 표현한다.
- 다중 컬럼으로 구성된 PK나 유니크 키 중에서 인덱스의 일부 컬럼만 조건으로 사용되는 경우 const 타입 접근 방법 사용이 불가능하다.
  - 실제 레코드가 1건만 저장되어 있더라도 MySQL 엔진이 이를 확신할 수 없기 때문
  - type 컬럼에 ref로 표시된다.
- MySQL 옵티마이저가 쿼리를 최적화하는 단계에서 먼저 실행해서 상수화한다.
  ```sql
    EXPLAIN
      SELECT COUNT(*)
      FROM employees e1
      WHERE first_name=(SELECT first_name FROM employees e2 WHERE emp_no=100001);
  ```
  ![img](./img/const2.png)

### 10.3.5.3 eq_ref
- 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다.
- 조인에서 처음 읽은 테이블의 컬럼 값을 다음 읽을 테이블의 PK나 유니크 키 컬럼의 검색 조건에 사용될 때 사용된다.
  - 두 번째 이후에 읽는 테이블의 type 컬럼에 eq_ref가 표시된다.
  - 두 번째 이후의 테이블을 유니크 키로 검색할 때 유니크 인덱스는 NOT NULL이어야 한다.
- 다중 컬럼으로 만들어진 PK나 유니크 인덱스라면 인덱스의 모든 컬럼이 비교 조건에 사용되어야 한다.
- 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있다.

```sql
  EXPLAIN
    SELECT *
    FROM dept_emp de, employees e
    WHERE e.emp_no=de.emp_no AND de.dept_no='d005';
```
![img](./img/eq_ref.png)

### 10.3.5.4 ref
> 인덱스의 종류와 관계없이 동등(equal) 조건으로 검색될 때 사용된다.

- 조인의 순서와 관계없이 사용된다.
- PK나 유니크 키 등의 제약 조건이 없다.
- 반환되는 레코드가 반드시 1건이라는 보장이 없으므로 const, eq_ref보다 빠르지 않다.
- 동등 조건으로만 비교되므로 빠른 레코드 조회 방법
```sql
  EXPLAIN
    SELECT *
    FROM dept_emp
    WHERE dept_no='d005';
```
![img](./img/ref1.png)
- PK의 일부만 where에 명시되었기 때문에 레코드가 1건이라는 보장이 없어서 const 대신 ref가 사용됨
- ref 컬럼의 const 값은 값 비교에 사용된 입력값이 상수라는 뜻 ('d005')

const, eq_req, ref 모두 where절에 동등 비교 연산자를 사용해야 한다.

### 10.3.5.5 fulltext
> MySQL 서버의 full-text search 인덱스를 사용해 레코드를 읽는 접근 방법

- 통계 정보가 관리되지 않으며, full-text search 인덱스를 사용하려면 전혀 다른 SQL 문법을 사용해야 한다.
- MySQL 서버에서 전문 검색 조건은 우선순위가 높다.
  - 인덱스의 접근 방법이 const나 eq_ref, ref가 아니면 전문 인덱스를 사용하는 조건을 선택해서 처리한다.
- `MATCH (...) AGAINST (...)` 구문을 사용해서 실행한다.
  - 이때 반드시 해당 테이블에 전문 검색용 인덱스가 준비되어 있어야 한다.
    ```sql
      CREATE TABLE employee_name (
        emp_no int NOT NULL,
        first_name varchar(14) NOT NULL,
        last_name varchar(16) NOT NULL,
        PRIMARY KEY(emp_no),
        FULLTEXT KEY fx_name (first_name, last_name) WITH PARSER ngram
      ) ENGINE=InnoDB;

      EXPLAIN
        SELECT *
        FROM employee_name
        WHERE emp_no=10001
          AND emp_no BETWEEN 10001 AND 10005
          AND MATCH(first_name, last_name) AGAINST('Facello' ON BOOLEAN MODE);
    ```
    ![img](./img/fulltext1.png)
    - employee_name 테이블의 PK를 1건만 조회하는 const 타입의 조건
    - range 타입의 조건
    - fulltext 타입의 조건
    ```sql
      EXPLAIN
        SELECT *
        FROM employee_name
        WHERE emp_no BETWEEN 10001 AND 10005
          AND MATCH(first_name, last_name) AGAINST('Facello' ON BOOLEAN MODE);
    ```
    ![img](./img/fulltext2.png)
    - const 타입의 조건을 제거하면 fulltext로 표시

### 10.3.5.6 ref_or_null
> ref 방식 또는 NULL 비교 (IS NULL) 접근 방법을 의미

```sql
  EXPLAIN
    SELECT * FROM titles
    WHERE to_date='1985-03-01' OR to_date IS NULL;
```

### 10.3.5.7 unique_subquery
> where 조건절에 사용될 수 있는 IN (subquery) 형태의 쿼리를 위한 접근 방법

- 서브쿼리에서 중복되지 않는 유니크한 값만 반환될 때 사용한다.

```sql
  EXPLAIN
    SELECT * FROM departments
    WHERE dept_no IN (SELECT dept_no FROM dept_emp WHERE emp_np=10001);
```

### 10.3.5.8 index_subquery
> 서브쿼리 결과의 중복된 값을 인덱스를 이용해서 제거할 수 있을 때 사용되는 접근 방법

- unique_subquery: IN (subquery) 형태의 조건에서 subquery의 반환 값에는 중복이 없으므로 별도의 중복 제거 작업이 필요하지 않다.
- index_subquery: IN (subquery) 형태의 조건에서 subquery의 반환 값에 중복된 값이 있을 수 있지만 인덱스를 이용해 중복된 값을 제거할 수 있다.

### 10.3.5.9 range
range: 인덱스를 하나의 값이 아닌 범위로 검색하는 경우
  - `<`, `>`, `IS NULL`, `BETWEEN`, `IN` `LIKE` 등의 연산자를 이용해 인덱스를 검색할 때 사용된다.
- MySQL 의 접근 방법 중에서 우선순위가 낮지만 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다고 볼 수 있다.

```sql
  EXPLAIN
    SELECT * FROM employees WHERE emp_no BETWEEN 10002 AND 10004;
```
![img](./img/range.png)

### 10.3.5.10 index_merge
> 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후 그 결과를 병합해서 처리하는 방식

특징
- 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방법보다는 효율성이 떨어진다.
- 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않는다.
- index_merge 접근 방법으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합 or 중복 제거와 같은 부가적인 작업이 더 필요하다.

```sql
  EXPLAIN
    SELECT * FROM employees
    WHERE emp_no BETWEEN 10001 AND 11000
      OR first_name='Smith';
```
![img](./img/index_merge.png)
- `emp_no` 조건은 PK를 이용해서 조회, `first_name` 조건은 ix_firstname 인덱스를 이용해 조회한 후 두 결과를 병합하는 형태로 처리한다.

### 10.3.5.11 index
> 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미

- 효율적으로 인덱스의 필요한 부분만 읽는 것을 의미하는 것은 아님
- 인덱스는 일반적으로 데이터 파일 전체보다 크기가 작으므로 풀 테이블 스캔보다 빠르게 처리되며, 쿼리의 내용에 따라 정렬된 인덱스의 장점을 이용할 수 있으므로 효율적이라고 할 수 있다.
- 아래 조건 중 (1, 2)번 or (1, 3)번 조건을 만족해야 한다.
  - range나 const, ref 같은 접근 방법으로 인덱스를 사용하지 못하는 경우
  - 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼리인 경우 (데이터 파일을 읽지 않아도 되는 경우)
  - 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우 (별도의 정렬 작업을 피할 수 있는 경우)

```sql
  EXPLAIN
    SELECT * FROM departments ORDER BY dept_name DESC LIMIT 10;
```
![img](./img/index.png)
- 아무런 where 조건이 없으므로 range, const, ref 접근 방법은 사용할 수 없음
- 정렬하려는 컬럼은 인덱스가 있으므로 별도의 정렬을 피하기 위해 index 접근 방법 사용

### 10.3.5.12 ALL
> 풀 테이블 스캔을 의미하는 접근 방법

- 테이블을 처음부터 끝까지 전부 읽어서 불필요한 레코드를 제외하고 반환한다.
- 다른 방법으로 처리할 수 없을 때 마지막에 선택하는 가장 비효율적인 방법
- 쿼리를 튜닝한다는 것이 무조건 인덱스 풀 스캔이나 풀 테이블 스캔을 사용하지 못하게 하는 것은 아니다.

index나 ALL 접근 방법은 작업 범위를 제한하는 조건이 아니므로 빠른 응답을 사용자에게 보내야 하는 웹 서비스와 같은 온라인 트랜잭션 처리 환경에는 적합하지 않다.

## 10.3.6 possible_keys 컬럼
- 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용되는 인덱스의 목록 (즉 사용될법했던 인덱스의 목록)
- 실행 계획 확인 시 특별한 경우를 제외하면 무시해도 된다.

## 10.3.7 key 컬럼
- 최종 선택된 실행 계획에서 사용하는 인덱스
- 쿼리 튜닝 시 key 컬럼에 의도했던 인덱스가 표시되는지 확인하는 것이 중요
  - PRIMARY: PK를 사용함
  - 이외의 값: 테이블이나 인덱스를 생성할 때 부여했던 고유 이름
- type컬럼이 index_merge가 아닌 경우에는 반드시 테이블 하나당 하나의 인덱스만 이용할 수 있다.
  - index_merge 사용 시 2개 이상의 인덱스가 사용되는데 `,`로 구분된다.
- 인덱스를 사용하지 못한다면 NULL로 표시된다.

## 10.3.8 key_len 컬럼
- 쿼리를 처리하기 위해 다중 컬럼으로 구성된 인덱스에서 몇 개의 컬럼까지 사용했는지 알려준다.
  - 정확하게는 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값
  - 다중 컬럼 인덱스뿐 아니라 단일 컬럼으로 만들어진 인덱스도 같은 지표를 제공한다.

```sql
  EXPLAIN
    SELECT * FROM dept_emp WHERE dept_no='d005';
```
![img](./img/key_len1.png)
- dept_no 컬럼의 타입이 CHAR(4)
- utf8mb4 문자 하나가 차지하는 공간은 1 ~ 4바이트로 가변적
- MySQL 서버가 utf8mb4 문자를 위해 메모리 공간을 할당할 때는 4바이트로 계산
- key_len 값은 4 * 4 = 16바이트로 표시

```sql
  CREATE TABLE titles (
    emp_no int NOT NULL,
    title varchar(50) NOT NULL,
    from_date date NOT NULL,
    to_date date DEFAULT NULL,
    PRIMARY KEY(emp_no, from_date, title),
    KEY ix_todate(to_date)
  );

  EXPLAIN
    SELECT * FROM titles WHERE to_date<='1985-10-10';
```
![img](./img/key_len2.png)
- to_date의 date 타입은 3바이트를 사용하지만 key_len은 4바이트로 표시되어 있다.
- to_date 컬럼이 date 타입을 사용하면서 null이 저장될 수 있는 컬럼으로 정의되었기 때문
- NOT NULL로 정의되지 않은 컬럼은 NULL인지 확인을 위해 1바이트를 더 사용한다.

## 10.3.9 ref 컬럼
- 접근 방법이 ref일 때 참조 조건 (equal 비교 조건)이 어떤 값으로 제공되었는지 보여준다.
  - 상수값을 지정했다면 const, 다른 테이블의 컬럼값이면 그 테이블명과 컬럼명이 표시된다.
  - ref 값이 func일 경우 콜레이션 반환이나 값 자체의 연산을 거쳐서 참조되었다는 것을 의미한다.
  ```sql
    EXPLAIN
      SELECT *
      FROM employees e, dept_emp de
      WHERE e.emp_no=de.emp_no;
  ```
  ![img](./img/ref2.png)
  - 조인 조건에 사용된 emp_no에 아무런 변환이나 가공을 하지 않음 -> ref 컬럼에 조인 대상 컬럼의 이름이 그대로 표시된다.

  ```sql
    EXPLAIN
      SELECT *
      FROM employees e, dept_emp de
      WHERE e.emp_no=(de.emp_no-1);
  ```
  ![img](./img/ref3.png)
  - emp_no - 1로 값이 가공되었음 -> func으로 표시된다.

## 10.3.10 rows 컬럼
> 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다.

- 각 스토리지 엔진별로 갖고 있는 통계 정보를 참조해 MySQL 옵티마이저가 산출해 낸 예상값이라서 정확하지는 않다.
- 반환하는 레코드가 아닌 쿼리 처리를 위해 읽어야 할 레코드를 의미

```sql
  EXPLAIN
    SELECT * FROM dept_emp WHERE from_date>='1985-01-01';
```
![img](./img/rows1.png)
- 옵티마이저가 쿼리를 처리하기 위해 331143건의 레코드를 읽어야할 것으로 예측
- dept_emp 테이블의 전체 레코드가 331143건이므로 풀 테이블 스캔을 선택

```sql
  EXPLAIN
    SELECT * FROM dept_emp WHERE from_date>='2022-07-01';
```
![img](./img/rows2.png)
- 옵티마이저가 292건의 레코드만 읽어도 되는것으로 예측

옵티마이저가 예측한 값은 대략의 값이며 틀릴 가능성이 높다.<br/>
대략의 수치는 어느정도 근접해야 하며, 그래야만 옵티마이저가 제대로 된 실행 계획을 수립할 수 있다.<br/>
가끔 컬럼의 값이 균등하게 분포되지 않은 경우 제대로 된 예측을 하지 못할 수 있음 -> MySQL 8.0부터 히스토그램 도입
