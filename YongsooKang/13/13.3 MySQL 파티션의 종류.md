# MySQL 파티션의 종류
- MySQL에서는 4가지 기본 파티션 기법을 제공한다.
  - 레인지 파티션
  - 리스트 파티션
  - 해시 파티션
  - 키 파티션

## 레인지 파티션
- 파티션 키의 연속된 범위로 파티션을 정의하는 방법
- `MAXVALUE` 키워드를 사용해서 명시되지 않은 범위의 키 값이 담긴 레코드를 저장하는 파티션을 정의할 수 있다.

### 레인지 파티션의 용도
- 레인지 파티션을 사용하기 좋은 테이블
  - 날짜를 기반으로 데이터가 누적되고 연도, 월, 일 단위로 분석하고 삭제해야 할 때
  - 범위 기반으로 데티러를 여러 파티션에 균등하게 나눌 수 있을 때
  - 파티션 키 위주로 검색이 자주 실행될 때
- 파티션의 장점
  - 큰 테이블을 작은 크기의 파티션으로 분리
  - 필요한 파티션만 접근 (쓰기/읽기 모두)
- ex. 로그 테이블

### 레인지 파티션 테이블 생성
```sql
  create table employees (
    id int not null,
    first_name varchar(30),
    last_name varchar(30),
    hired date not null default '1970-01-01',
    ...
  ) partition by range( year(hired) ) (
    partition p0 values less than (1991),
    partition p1 values less than (1996),
    partition p2 values less than (2001),
    partition p3 values less than maxvalue
  );
```
- partition by range 키워드로 레인지 파티션을 정의
- partition by range 뒤에 컬럼 or 내장 함수를 이용하여 파티션 키를 명시
- values less than으로 명시된 값보다 작은 값만 해당 파티션에 저장하게 설정
  - less than절에 명시된 값은 해당 파티션에 포함되지 않음
- values less than maxvalue로 명시되지 않은 레코드를 저장할 파티션을 지정
- values less than maxvalue가 정의되지 않으면 범위를 벗어난 입력이 들어올 경우 에러가 발생한다.
  - `Table has no partition for value 2011` 메시지 표시
- 테이블과 각 파티션은 같은 스토리지 엔진으로 정의할 수 있다.
  - MySQL 8.0 InnoDB 스토리지 엔진이 default라서 별도로 명시하지 않아도 됨

### 레인지 파티션의 분리와 병합
#### 단순 파티션의 추가
```sql
  alter table employees
    add partition (partition p4 values less than (2011));
```
- 해당 테이블에서 이미 `less than maxvalue`를 갖고 있는 경우
  - `maxvalue can only be used in last partition definition` 에러가 발생한다.
  - 이미 레코드가 쌓인 상태에서 2011년 파티션이 추가된다면 2011년 레코드는 2개의 파티션에 나눠서 저장되는 결과가 된다.
  - `alter table ... reorganize partition` 명령을 사용해야 한다.
    ```sql
      alter table employees algorithm=inplace, lock=shared,
        reorganize partition p3 into (
          partition p3 values less than (2011),
          partition p4 values less than maxvalue
        );
    ```
    - p3 파티션의 레코드를 새로운 두 개의 파티션으로 복사하는 작업이 필요
    - 기존의 p3 파티션의 레코드가 많을수록 오래걸림
- 레인지 파티션에서는 일반적으로 `less than maxvalue` 보다는 미래에 사용될 파티션을 미리 2 ~ 3개정도 더 만들어 두는 형태로 테이블을 생성하기도 한다.
  - 배치 스크립트를 이용해서 주기적으로 파티션 테이블의 여유 기간을 판단해서 자동으로 추가하는 방법을 사용함

#### 파티션 삭제
```sql
  alter table employees drop partition p0;
```
- drop partition 키워드에 삭제하려는 파티션의 이름을 지정한다.
- 처리속도가 빨라서 날짜 단위로 파티션된 테이블에서 오래된 데이터를 삭제하는 용도로 자주 사용된다.
- 레인지 파티션을 사용하는 테이블에서는 가장 오래된 파티션 순서로만 삭제가 가능하다.

#### 기존 파티션의 분리
```sql
  alter table employees algorithm=inplace, lock=shared,
    reorganize partition p3 into (
      partition p3 values less than (2011),
      partition p4 values less than maxvalue
    );
```
- 하나의 파티션을 두 개 이상의 파티션으로 분리
- `reorganize partition` 명령을 사용한다.
- 기존 파티션의 레코드가 많다면 온라인 ddl로 실행할 수 있도록 algorithm, lock을 사용한다.
- 파티션이 재구성되는 동안은 테이블의 쓰기가 불가능해지므로 서비스 점검 시간대나 쿼리 처리가 많지 않은 시간대에 진행하는 것이 좋음

#### 기존 파티션의 병합
```sql
  alter table employees algorithm=inplace, lock=shared,
    reorganize partition p2, p3 into (
      partition p23 values less than (2011)
    );
```
- `reorganize partition` 명령을 사용한다.
- 테이블에 대해서 읽기 잠금을 필요로 한다.

## 리스트 파티션
- 레인지 파티션은 파티션 키 값의 범위로 파티션을 구성할 수 있다.
- 리스트 파티션은 파티션 키 값 하나하나를 리스트로 나열해야 한다.
- maxvalue 파티션을 정의할 수 없다.

### 리스트 파티션의 용도
- 리스트 파티션을 사용하기 좋은 테이블
  - 파티션 키 값이 코드 값이나 카테고리와 같이 고정적일 때
  - 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야할 때
  - 파티션 키 값을 기준으로 레코드의 건수가 균일하고 검색 조건에 파티션 키가 자주 사용될 때

### 리스트 파티션 테이블 생성
```sql
  create table product (
    id int not null,
    name varchar(30),
    category_id int not null,
    ...
  ) partition by list( category_id ) (
    partition p_appliance values in (3),
    partition p_computer values in (1, 9),
    partition p_sports values in (2, 6, 7),
    partition p_etc values in (4, 5, 8, null)
  );
```
- partition by list 키워드로 생성할 파티션이 리스트 파티션임을 명시
- partition by list 키워드 뒤에 파티션 키를 정의
- values in (...)를 사용해서 파티션별로 저장할 파티션 키 값의 목록을 나열
- 파티션별로 저장할 키 값 중에 null을 명시할 수 있음
- 레인지 파티션과는 달리 나머지 모든 값을 저장하는 maxvalue 파티션은 정의할 수 없음

### 리스트 파티션의 분리와 병합
- 파티션 정의 부분에서 `values less than`이 아닌 `values in`을 사용하는 것 외에는 레인지 파티션 방법과 같음

### 리스트 파티션 주의사항
- 명시되지 않은 나머지 값을 저장하는 maxvalue 파티션을 정의할 수 없음
- 레인지 파티션과는 달리 null을 저장하는 파티션을 별도로 생성할 수 있음
