[5.2 MySQL 엔진의 잠금](#52-mysql-엔진의-잠금)
- [5.2.1 글로벌 락](#521-글로벌-락)
- [5.2.2 테이블 락](#522-테이블-락)
- [5.2.3 네임드 락](#523-네임드-락)
- [5.2.4 메타데이터 락](#524-메타데이터-락)

# 5.2 MySQL 엔진의 잠금
- MySQL에서 사용되는 잠금은 `스토리지 엔진 레벨`과 `MySQL 엔진 레벨`로 나눌 수 있다.
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미친다.
- 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.

## 5.2.1 글로벌 락
> MySQL에서 제공하는 잠금 중 가장 범위가 크다.
- `FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있다.
- 한 세션에서 글로벌 락을 획득하면 다른 세션에서 select를 제외한 대부분의 DDL, DML 문장을 실행할 때 글로벌 락이 해제될 때까지 대기상태로 남는다.
- 글로벌 락의 영향을 미치는 범위는 MySQL 서버 전체이며, DB나 테이블이 다르더라도 영향을 미친다.
- InnoDB 스토리지 엔진은 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요는 없다.
- MySQL 8.0부터는 InnoDB가 default이므로 조금 더 가벼운 글로벌 락의 필요성이 생겼다.
    - Xtrabackup, Enterprise Backup과 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입됐다.
    - 특정 세션에서 백업 락을 획득하면 모든 세션에서 테이블의 스키마나 사용자의 인증 관련정보를 변경할 수 없게된다.
        - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
        - REPAIR TABLE, OPTIMIZE TABLE 명령
        - 사용자 관리 및 비밀번호 변경

## 5.2.2 테이블 락
> 개별 테이블 단위로 설정되는 잠금
- 명시적 or 묵시적으로 특정 테이블의 락을 획득할 수 있다.
    - 명시적으로는 `LOCK TABLES table_name READ/WRITE` 명령으로 획득한다.
- InnoDB 테이블에도 테이블 락이 설정된다.
    - 대부분의 데이터 변경(DML) 쿼리에서는 무시된다.
    - 스키마를 변경하는 DDL 쿼리의 경우에만 영향을 미친다.

## 5.2.3 네임드 락
> 단순히 사용자가 지정한 문자열에 대해 잠금을 획득하고 반납하는 잠금이다.
- GET_LOCK() 함수를 이용해 임의의 `문자열`에 대해 잠금을 설정할 수 있다.
    - 잠금의 대상이 테이블, 레코드, 데이터베이스 객체가 아니다.
    - 자주 사용되지는 않는다.
    - 데이터베이스 서버 1대에 5대의 웹 서버가 서비스되고 있는 상황에서 어떤 정보를 동기화 처리할 때 사용된다.
    - ```sql
        -- 'mylock' 문자열에 대한 잠금을 획득, 이미 사용중이면 2초 대기
        SELECT GET_LOCK('mylock', 2);

        -- 'mylock' 문자열에 대한 잠금이 적용되어 있는지 확인
        SELECT IS_FREE_LOCK('mylock');

        -- 'mylock' 문자열에 대한 잠금 해제
        SELECT RELEASE_LOCK('mylock');

        -- 위 함수들 모두 정상적으로 동작 시 1, 아니면 NULL or 0을 반환한다.
        ```
- MySQL 8.0부터는 네임드 락을 중첩해서 사용하거나 모든 네임드 락을 한번에 해제하는 기능이 추가되었다.

## 5.2.4 메타데이터 락
> 데이터베이스 객체의 이름이나 구조를 변경하는 경우 획득하는 잠금
- 명시적으로 획득하거나 해제할 수 있는 것이 아니다.
- `RENAME TABLE tab_a TO tab_b` 명령어 같이 테이블의 이름을 변경하는 경우 자동으로 획득한다.
    - `RENAME`의 경우 현재 이름(tab_a)과 변경될 이름(tab_b) 모두 잠금을 획득한다.
    - `RENAME TABLE tab_a TO tab_b, tab_c TO tab_a;`
        - 하나의 명령문에 여러개의 작업을 한꺼번에 실행하여 적용이 가능하다.
    - ```sql
        RENAME TABLE tab_a TO tab_b;
        -- 여기서 tab_a 테이블에 접근하는 코드 실행 시 not found 에러 발생
        RENAME TABLE tab_c TO tab_a;
        ```
        - 2개의 명령문으로 나눈다면 rank 테이블이 존재하지 않는 순간이 짧게나마 생긴다.
        - 그 순간에 `Table not found 'rank'` 오류가 발생한다.
- 메타데이터 잠금과 InnoDB의 트랜잭션을 동시에 사용해야 하는 경우도 있다.
    - ex) 테이블의 구조를 변경해야 할 때
        - DDL을 이용하여 변경할 수 있지만 시간이 너무 오래걸린다면 언두 로그의 증가, DDL이 실행되는 동안 누적된 DDL 버퍼의 크기 등 고민할 문제가 많다.
        - MySQL 서버의 DDL은 단일 스레드로 작동하기 때문에 상당히 많은 시간이 소모될 것이다.
        - 새로운 구조의 테이블을 생성하고 최근의 데이터까지는 pk 값을 범위별로 나눠서 여러개의 스레드로 빠르게 복사한다.
        - 나머지 데이터는 트랜잭션과 테이블 잠금, RENAME TABLE 명령으로 응용프로그램의 중단 없이 실행할 수 있다.
        - 가능하면 미리 최근 데이터를 복사해둬야 잠금 시간을 최소화해서 서비스에 미치는 영향을 줄일 수 있다.
