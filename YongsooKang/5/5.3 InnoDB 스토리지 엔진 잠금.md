[5.3 InnoDB 스토리지 엔진 잠금](#53-innodb-스토리지-엔진-잠금)
- [5.3.1 InnoDB 스토리지 엔진의 잠금](#531-innodb-스토리지-엔진의-잠금)
    - [5.3.1.1 레코드 락](#5311-레코드-락)
    - [5.3.1.2 갭 락](#5312-갭-락)
    - [5.3.1.3 넥스트 키 락](#5313-넥스트-키-락)
    - [5.3.1.4 자동 증가 락](#5314-자동-증가-락)
- [5.3.2 인덱스와 잠금](#532-인덱스와-잠금)
- [5.3.3 레코드 수준의 잠금 확인 및 해제](#533-레코드-수준의-잠금-확인-및-해제)

# 5.3 InnoDB 스토리지 엔진 잠금
- InnoDB 스토리지 엔진은 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다.
    - 이 방식때문에 MyISAM보다 훨씬 뛰어난 동시성 처리를 제공할 수 있다.
    - 이원화된 잠금 처리 탓에 InnoDB 스토리지 엔진에서 사용되는 잠금 정보는 MySQL 명령을 이용한 접근이 어렵다.
- 최근 버전에서 InnoDB의 트랜잭션과 잠금 / 잠금 대기 중인 트랜잭션의 목록을 조회할 수 있는 방법이 도입됐다.

## 5.3.1 InnoDB 스토리지 엔진의 잠금
![img](./img/5.1%20InnoDB%20%EC%9E%A0%EA%B8%88%EC%9D%98%20%EC%A2%85%EB%A5%98.png)
- InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공한다.
- 잠금 정보가 상당히 적은 공간으로 관리되기 때문에 레코드 락이 페이지 락 or 테이블 락으로 레벨업되는 경우는 없다.
- 일반 상용 DBMS와는 다르게 레코드 락 뿐만 아니라 레코드와 레코드 사이의 간격을 잠그는 갭 락이 존재한다.

### 5.3.1.1 레코드 락
> 레코드 자체만을 잠그는 락
- 다른 상용 DBMS의 레코드 락과 동일한 역할
- 차이는 InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
- 인덱스가 하나도 없는 테이블이라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.
- 대부분 보조 인덱스를 이용한 변경 작업은 넥스트 키 락 or 갭 락을 사용한다.
- PK or 유니크 인덱스에 의한 변경 작업에서는 갭에 대한 잠금은 없으며, 레코드에 대해서만 락을 건다.

### 5.3.1.2 갭 락
> 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 락
- 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어한다.

### 5.3.1.3 넥스트 키 락
> 레코드 락 + 갭 락
- STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEATABLE READ 격리 수준을 사용해야 한다.
- InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적이다.
- 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리는 일이 자주 발생한다.
    - 가능하면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.

### 5.3.1.4 자동 증가 락
- 자동 증가하는 숫자 값을 추출하기 위해 `AUTO_INCREMENT` 컬럼을 제공한다.
- 위 컬럼이 사용된 테이블에 동시에 여러 레코드가 INSERT될 경우 저장되는 각 레코드는 중복되지 않고, 저장되는 순서대로 증가하는 값을 가진다.
    - 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금을 사용한다.
- INSERT, REPLACE 쿼리와 같이 새로운 레코드를 저장하는 쿼리에서만 필요하며, UPDATE, DELETE 등의 쿼리에서는 걸리지 않는다.
    - INSERT, REPLACE 쿼리에서 AI 값을 가져오는 순간에만 락이 걸리고, 바로 해제된다.
    - 테이블에 하나만 존재하므로 두개 이상의 쿼리가 실행되면 하나의 쿼리에 의해 락이 걸릴때 다른 쿼리는 기다린다.
- 명시적으로 획득하고 해제하는 방법은 없다.
- MySQL 5.1 이상부터는 `innodb_autoinc_lock_mode` 시스템 변수를 이용해 작동 방식을 변경할 수 있다.
    - `innodb_autoinc_lock_mode = 0`
        - 모든 insert 문장은 자동 증가 락을 사용한다.
    - `innodb_autoinc_lock_mode = 1`
        - 단순한 insert에는 레코드의 건수를 정확히 예측할 수 있으면 자동 증가 락을 사용하지 않고, 훨씬 가볍고 빠른 Mutex를 이용해 처리한다.
    - `innodb_autoinc_lock_mode = 2`
        - InnoDB 스토리지 엔진은 절대 자동 증가 락을 걸지 않고 경량화된 Mutex를 사용한다.
        - 하나의 insert에도 연속된 자동 증가 값을 보장하지는 않는다.

## 5.3.2 인덱스와 잠금
> InnoDB의 잠금은 레코드가 아닌 인덱스를 잠그는 방식이다.
- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.
- `UPDATE employees SET hire_date=now() WHERE first_name='Georgi' AND last_name='Klassen';`
    - UPDATE 쿼리 실행 시 인덱스를 이용할 수 있는 조건은 `first_name='Georgi'`으로 이 조건을 만족하는 레코드가 모두 잠긴다.
- 인덱스가 하나도 없다면 모든 레코드가 잠긴다.
    - 클라이언트 간의 동시성이 떨어져서 한 세션에서 update 작업을 하는동안 다른 클라이언트는 계속 기다려야 한다.
    - 위와 같은 일이 발생하지 않도록 적절하게 인덱스를 준비하도록 한다.

## 5.3.3 레코드 수준의 잠금 확인 및 해제
- 테이블 잠금에서는 잠금의 대상이 테이블 자체이므로 쉽게 문제의 원인이 발견되고 해결될 수 있다.
- 예전 버전의 MySQL 서버는 레코드 잠금에 대한 메타 정보를 제공하지 않는다.
- MySQL 5.1 부터는 레코드 잠금과 잠금 대기에 대한 조회가 가능하므로 쿼리 하나만 실행해보면 각 트랜잭션이 어떤 잠금을 기다리는지, 기다리고 있는 잠금을 어떤 트랜잭션이 갖고 있는지 확인할 수 있다.
- 강제로 잠금을 해제하려면 `KILL` 명령으로 강제 종료한다.
- 커넥션 1
    ```
    BEGIN;
    UPDATE employees SET birth_date=now() WHERE emp_no=100001;
    ```
- 커넥션 2
    ```
    UPDATE employees SET hire_date=now() WHERE emp_no=100001;
    ```
- 커넥션 3
    ```
    UPDATE employees SET hire_date=now(), birth_date=now() WHERE emp_no=100001;
    ```
- MySQL 5.1 부터는 `information_schema`의 `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS` 테이블을 통해 확인이 가능했다.
- MySQL 8.0 부터는 `information_schema`의 정보들은 조금씩 제거되고 있고, `performance_schema`의 `data_locks`, `data_lock_waits` 테이블로 대체되고 있다.
