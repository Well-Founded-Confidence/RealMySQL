[5.1.1 MySQL에서의 트랜잭션](#511-mysql에서의-트랜잭션)

[5.1.2 주의사항](#512-주의사항)

[5.2 MySQL 엔진의 잠금](#52-mysql-엔진의-잠금)
- [5.2.1 글로벌 락](#521-글로벌-락)
- [5.2.2 테이블 락](#522-테이블-락)
- [5.2.3 네임드 락](#523-네임드-락)
- [5.2.4 메타데이터 락](#524-메타데이터-락)

# 5.1.1 MySQL에서의 트랜잭션
> 하나의 논리적인 작업 세트가 모두 적용되거나 1도 적용된 것이 없음을 보장한다.
- MyISAM vs InnoDB
    - ```sql
        insert into table(pk) values (1),(2),(3)
        -- 테이블에 pk=3인 row가 있다고 가정 => pk 중복 오류 발생
        -- MyISAM은 insert했던 1, 2가 그대로 남아있다.
        -- InnoDB는 insert했던 1, 2가 제거된다.
        ```

# 5.1.2 주의사항
- 프로그램 코드에서 트랜잭션 범위를 최소화하는 것이 좋다.
- ex) 사용자가 게시판에 게시물을 작성한 후 저장 버튼을 클릭했을 때 서버에서 처리하는 내용
    - ```
        1) 처리 시작
            - 데이터베이스 커넥션 생성
            - 트랜잭션 시작
        2) 사용자의 로그인 여부 확인
        3) 사용자의 글쓰기 내용의 오류 여부 확인
        4) 첨부로 업로드된 파일 확인 및 저장
        5) 사용자의 입력 내용을 DBMS에 저장
        6) 첨부 파일 정보를 DBMS에 저장
        7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
        8) 게시물 등록에 대한 알림 메일 발송
        9) 알림 메일 발송 이력을 DBMS에 저장
            - 트랜잭션 종료 (commit)
            - 데이터베이스 커넥션 반납
        10) 처리 완료
        ```
    - DB 커넥션은 갯수가 제한적이므로 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질 수록 사용 가능한 여유 커넥션의 개수는 줄어들 것이다.
    - 8번 작업처러 메일 전송과 같은 외부 서버를 이용하는 경우는 어떻게든 DBMS 트랜잭션에서 제거하는 것이 좋다.
    - 이 처리 절차에는 DBMS 작업이 크게 4개가 있다.
        - 사용자가 입력한 정보를 저장하는 5, 6번 작업은 반드시 하나의 트랜잭션으로 묶어야 한다.
        - 7번 작업은 저장된 데이터의 단순 확인 및 조회이므로 트랜잭션에 포함할 필요는 없다.
        - 9번 작업은 조금 성격이 다르기 때문에 별도의 트랜잭션으로 분리하는 것이 좋다.
        - 7번 작업은 단순 조회라고 본다면 별도로 트랜잭션을 사용하지 않아도 된다.
    - ```
        1) 처리 시작
        2) 사용자의 로그인 여부 확인
        3) 사용자의 글쓰기 내용의 오류 여부 확인
        4) 첨부로 업로드된 파일 확인 및 저장
            - 데이터베이스 커넥션 생성
            - 트랜잭션 시작
        5) 사용자의 입력 내용을 DBMS에 저장
        6) 첨부 파일 정보를 DBMS에 저장
            - 트랜잭션 종료
        7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
        8) 게시물 등록에 대한 알림 메일 발송
            - 트랜잭션 시작
        9) 알림 메일 발송 이력을 DBMS에 저장
            - 트랜잭션 종료 (commit)
            - 데이터베이스 커넥션 반납
        10) 처리 완료
        ```

# 5.2 MySQL 엔진의 잠금
- MySQL에서 사용되는 잠금은 `스토리지 엔진 레벨`과 `MySQL 엔진 레벨`로 나눌 수 있다.
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미친다.
- 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.

## 5.2.1 글로벌 락
> MySQL에서 제공하는 잠금 중 가장 범위가 크다.
- `FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있다.
- 한 세션에서 글로벌 락을 획득하면 다른 세션에서 select를 제외한 대부분의 DDL, DML 문장을 실행할 때 글로벌 락이 해제될 때까지 대기상태로 남는다.
- 글로벌 락의 영향을 미치는 범위는 MySQL 서버 전체이며, DB나 테이블이 다르더라도 영향을 미친다.
- InnoDB 스토리지 엔진은 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요는 없다.
- MySQL 8.0부터는 InnoDB가 default이므로 조금 더 가벼운 글로벌 락의 필요성이 생겼다.
    - Xtrabackup, Enterprise Backup과 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입됐다.
    - 특정 세션에서 백업 락을 획득하면 모든 세션에서 테이블의 스키마나 사용자의 인증 관련정보를 변경할 수 없게된다.
        - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
        - REPAIR TABLE, OPTIMIZE TABLE 명령
        - 사용자 관리 및 비밀번호 변경

## 5.2.2 테이블 락
> 개별 테이블 단위로 설정되는 잠금
- 명시적 or 묵시적으로 특정 테이블의 락을 획득할 수 있다.
    - 명시적으로는 `LOCK TABLES table_name READ/WRITE` 명령으로 획득한다.
- InnoDB 테이블에도 테이블 락이 설정된다.
    - 대부분의 데이터 변경(DML) 쿼리에서는 무시된다.
    - 스키마를 변경하는 DDL 쿼리의 경우에만 영향을 미친다.

## 5.2.3 네임드 락
> 단순히 사용자가 지정한 문자열에 대해 잠금을 획득하고 반납하는 잠금이다.
- GET_LOCK() 함수를 이용해 임의의 `문자열`에 대해 잠금을 설정할 수 있다.
    - 잠금의 대상이 테이블, 레코드, 데이터베이스 객체가 아니다.
    - 자주 사용되지는 않는다.
    - 데이터베이스 서버 1대에 5대의 웹 서버가 서비스되고 있는 상황에서 어떤 정보를 동기화 처리할 때 사용된다.
    - ```sql
        -- 'mylock' 문자열에 대한 잠금을 획득, 이미 사용중이면 2초 대기
        SELECT GET_LOCK('mylock', 2);

        -- 'mylock' 문자열에 대한 잠금이 적용되어 있는지 확인
        SELECT IS_FREE_LOCK('mylock');

        -- 'mylock' 문자열에 대한 잠금 해제
        SELECT RELEASE_LOCK('mylock');

        -- 위 함수들 모두 정상적으로 동작 시 1, 아니면 NULL or 0을 반환한다.
        ```
- MySQL 8.0부터는 네임드 락을 중첩해서 사용하거나 모든 네임드 락을 한번에 해제하는 기능이 추가되었다.

## 5.2.4 메타데이터 락
> 데이터베이스 객체의 이름이나 구조를 변경하는 경우 획득하는 잠금
- 명시적으로 획득하거나 해제할 수 있는 것이 아니다.
- `RENAME TABLE tab_a TO tab_b` 명령어 같이 테이블의 이름을 변경하는 경우 자동으로 획득한다.
    - `RENAME`의 경우 현재 이름(tab_a)과 변경될 이름(tab_b) 모두 잠금을 획득한다.
    - `RENAME TABLE tab_a TO tab_b, tab_c TO tab_a;`
        - 하나의 명령문에 여러개의 작업을 한꺼번에 실행하여 적용이 가능하다.
    - ```sql
        RENAME TABLE tab_a TO tab_b;
        RENAME TABLE tab_c TO tab_a;
        ```
        - 2개의 명령문으로 나눈다면 rank 테이블이 존재하지 않는 순간이 짧게나마 생긴다.
        - 그 순간에 `Table not found 'rank'` 오류가 발생한다.
- 메타데이터 잠금과 InnoDB의 트랜잭션을 동시에 사용해야 하는 경우도 있다.
    - ex) 테이블의 구조를 변경해야 할 때
        - DDL을 이용하여 변경할 수 있지만 시간이 너무 오래걸린다면 언두 로그의 증가, DDL이 실행되는 동안 누적된 DDL 버퍼의 크기 등 고민할 문제가 많다.
        - MySQL 서버의 DDL은 단일 스레드로 작동하기 때문에 상당히 많은 시간이 소모될 것이다.
        - 새로운 구조의 테이블을 생성하고 최근의 데이터까지는 pk 값을 범위별로 나눠서 여러개의 스레드로 빠르게 복사한다.
        - 나머지 데이터는 트랜잭션과 테이블 잠금, RENAME TABLE 명령으로 응용프로그램의 중단 없이 실행할 수 있다.
        - 가능하면 미리 최근 데이터를 복사해둬야 잠금 시간을 최소화해서 서비스에 미치는 영향을 줄일 수 있다.