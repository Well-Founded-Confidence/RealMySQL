## SELECT 절의 처리 순서
- SELECT 문장 = SQL 전체
- 절: 키워드(select, from, join, where, group by, having, order by, limit) + 표현식

![img](./img/11.3%20각%20쿼리%20절의%20실행%20순서.png)
![img](./img/11.4%20쿼리%20각%20절의%20실행%20순서%20(예외적으로%20order%20by가%20조인보다%20먼저%20실행되는%20경우).png)
- 첫 번째 테이블만 읽어서 정렬 수행 -> 나머지 테이블을 읽음
- 주로 group by 없이 order by만 사용된 쿼리에서 사용될 수 있는 순서

## WHERE절과 GROUP BY절, ORDER BY절의 인덱스 사용
### 인덱스를 사용하기 위한 기본 규칙
- 기본적으로 인덱스된 컬럼의 값 자체를 변환하지 않고 그대로 사용한다는 조건을 만족해야 함
  ```sql
    -- salary 값을 가공했기 때문에 인덱스를 사용할 수 없음
    select * from selaries where salary*10 > 150000;

    select * from selaries where salary > 150000/10;
  ```
  - 만약 복잡한 연산을 수행한다거나 MD5() 함수와 같은 해시 값을 만들어서 비교할 경우 미리 계산된 값을 저장하도록 MySQL의 가상 컬럼을 추가하고, 그 컬럼에 인덱스를 생성하거나 함수 기반의 인덱스를 사용하면 된다.
- 인덱스는 컬럼의 값을 아무런 변환 없이 B-Tree에 정렬해서 저장한다.
- where, group by, order by에서도 원본값을 검색하거나 정렬할 때만 b-tree에 정렬된 인덱스를 이용한다.
- where절에 사용되는 비교 조건에서 연산자 양쪽의 값들은 데이터 타입이 같아야 한다.
  ```sql
    create table tb_test (age varchar(10), index ix_age(age));
    insert into tb_test values('1'), ('2'), ('3'), ('4'), ('5'), ('6'), ('7');
    select * from tb_test where age=2;

    select * from tb_test where age='2';
  ```
  - MySQL 옵티마이저가 내부적으로 타입을 변환한 후 비교작업을 처리한다.
    - 인덱스 레인지 스캔이 아닌 인덱스 풀 스캔으로 처리됨

### WHERE절의 인덱스 사용
![img](./img/11.5%20where%20조건의%20인덱스%20사용%20규칙.png)
- 위쪽은 4개 컬럼이 순서대로 결합 인덱스로 생성되어 있음을 의미
- 아래쪽은 SQL의 where절에 존재하는 조건을 의미
- where절에 나열된 순서가 달라도 MySQL 옵티마이저가 인덱스를 사용할 수 있는 조건들을 뽑아서 최적화할 수 있다.

```sql
  alter table ... add index ix_col1234 (col_1 asc, col_2 desc, col_3 asc, col_4 asc);
```
- MySQL 8.0 이전까지는 하나의 인덱스를 구성하는 각 컬럼의 정렬 순서가 혼합되어 사용할 수 없었다.
- MySQL 8.0 부터는 인덱스를 구성하는 컬럼별로 정렬 기준을 혼합해서 생성할 수 있게 되었다.

### GROUP BY절의 인덱스 사용
- group by절의 각 컬럼은 비교연산자를 가지지 않으므로 작업 범위 결정 조건이나 체크 조건과 같이 구분해서 생각할 필요 없음
- group by절에 명시된 컬럼의 순서가 인덱스를 구성하는 컬럼의 순서와 같으면 인덱스를 이용할 수 있다.

![img](./img/11.6%20group%20by절의%20인덱스%20사용%20규칙.png)
- group by절에 명시된 컬럼이 인덱스 컬럼의 순서와 같아야 한다.
- 인덱스를 구성하는 컬럼 중에서 뒤쪽에 있는 컬럼은 group by절에 명시되지 않아도 인덱스를 사용할 수 있지만 앞쪽의 컬럼은 group by절에 명시되지 않으면 인덱스를 사용할 수 없다.
- where 조건절과는 달리 group by절에 명시된 컬럼이 하나라도 인덱스에 없으면 group by절은 전혀 인덱스를 사용하지 못한다.

```sql
  group by col_2, col_1
  group by col_1, col_3, col_2
  group by col_1, col_3
  group by col_1, col_2, col_3, col_4, col_5
```
- 1, 2는 순서가 일치하지 않음
- 3은 col_2가 명시되지 않음
- 4는 col_5가 인덱스에 존재하지 않음

```sql
  where col_1='1' group by col_2, col_3
  where col_1='1' and col_2='2' group by col_3, col_4
  where col_1='1' and col_2='2' and col_3='3' group by col_4
```
- group by에 명시되지 않은 앞쪽의 컬럼이 where절에 명시되었다면 인덱스를 사용할 수 있다.

### ORDER BY절의 인덱스 사용
- group by의 조건 + 정렬되는 각 컬럼의 오름차순 or 내림차순 옵션이 인덱스와 같거나 정반대인 경우에만 사용할 수 있다.

![img](./img/11.7%20order%20by절의%20인덱스%20사용%20규칙.png)
```sql
  order by col_2, col_3
  order by col_1, col_3, col_2
  order by col_1, col_2 desc, col_3
  order by col_1, col_3
  order by col_1, col_2, col_3, col_4, col_5
```
- 1은 col_1이 명시되지 않음
- 2는 순서가 일치하지 않음
- 3은 col_2의 정렬 순서가 다름
- 4는 col_2가 명시되지 않음
- 5는 col_5가 인덱스에 존재하지 않음

### WHERE 조건과 ORDER BY(GROUP BY)절의 인덱스 사용
- 하나의 sql 문장에서 where 조건은 A 인덱스, order by는 B 인덱스를 사용할 수는 없다.
- where + order by가 사용된 쿼리에서 인덱스를 이용하는 방법
  - where, order by 동시에 같은 인덱스 이용
    - where에 사용된 컬럼 + order by에 사용된 컬럼이 모두 하나의 인덱스에 연속해서 포함되어 있을 때 가능
    - 아래 두가지 방법보다 훨씬 빠른 성능
  - where만 인덱스 이용
    - order by절은 인덱스를 이용한 정렬이 불가능하며, 인덱스를 통해 검색된 결과 레코드를 별도의 정렬 처리과정을 거쳐 정렬을 수행한다.
    - where절의 조건에 일치하는 레코드 건수가 많지 않을 때 효율적인 방식
  - order by만 인덱스 이용
    - order by절의 순서대로 인덱스를 읽으면서 레코드 한건씩 where 조건에 일치하는지 비교하고, 일치하지 않으면 버림
    - 아주 많은 레코드를 조회해서 정렬해야 할 때 사용함
- where에 사용된 컬럼 + order by에 사용된 컬럼이 순서대로 빠짐없이 인덱스 컬럼의 왼쪽부터 일치해야 한다.
  - where과 order by에 같은 컬럼이 사용되는 것은 문제되지 않음

![img](./img/11.8%20where절과%20order%20by절의%20인덱스%20사용%20규칙.png)
- where + order by가 결합된 두 가지 패턴의 쿼리
- order by절에 컬럼이 사용되고 있다면 where절에 동등비교 이외의 연산자로 비교해도 된다.

```sql
  select * from tb_test where col_1 > 10 order by col_1, col_2, col_3;
  select * from tb_test where col_1 > 10 order by col_2, col_3;
```
- 1번 쿼리는 인덱스로 사용할 컬럼을 순서대로 모두 명시했으므로 정상적으로 인덱스 사용 가능
- 2번 쿼리는 col_1을 범위조건으로 검색되었고, order by에는 명시되지 않아서 정렬할 때는 인덱스를 사용할 수 없다.

### GROUP BY절과 ORDER BY절의 인덱스 사용
- group by, order by가 동시에 사용된 쿼리에서 동시에 하나의 인덱스를 사용하려면 group by에 명시된 컬럼과 order by에 명시된 컬럼의 순서와 내용이 모두 같아야 한다.
  - 어느 한쪽이라도 인덱스를 이용할 수 없다면 둘 다 인덱스를 이용할 수 없다.

```sql
  group by col_1, col_2 order by col_2
  group by col_1, col_2 order by col_1, col_3
```
- MySQL 5.7 까지는 group by는 group by 컬럼에 대한 정렬까지 함께 수행하는 것이 기본 작동 방식이었다.
- MySQL 8.0 부터는 group by절이 컬럼의 정렬까지는 보장하지 않는 형태로 바뀜
  - 그루핑과 정렬 모두 수행하려면 group by, order by절을 모두 명시해야 한다.

### WHERE 조건과 ORDER BY절, GROUP BY절의 인덱스 사용
![img](./img/11.9%20where조건과%20order%20by절,%20group%20by절의%20인덱스%20사용%20여부%20판단.png)
- where, group by, order by가 모두 포함된 쿼리가 인덱스를 사용하는지 판단하는 방법
  1. where절이 인덱스를 사용할 수 있는지
  2. group by절이 인덱스를 사용할 수 있는지
  3. group by절과 order by절이 동시에 인덱스를 사용할 수 있는지
