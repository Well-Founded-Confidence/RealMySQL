## 온라인 DDL
- MySQL 5.5 이전까지는 MySQL 서버에서 테이블의 구조를 변경하는 동안에는 다른 커넥션에서 DML을 실행할 수가 없었다.
  - 문제 해결을 위해 Percona에서 개발한 pt-online-schema-change 도구를 사용함
  - MySQL 5.5 버전도 온라인 DDL 성능, 안정성 등의 이유로 pt-online-schema-change 사용
- MySQL 8.0 부터는 대부분의 스키마 변경 작업은 MySQL 서버에 내장된 온라인 DDL 기능으로 처리가 가능해짐
  - pt-online-schema-change는 이제 거의 사용되지 않음

### 온라인 DDL 알고리즘
- 온라인 DDL은 스키마를 변경하는 작업도중에도 다른 커넥션에서 해당 테이블의 데이터를 변경/조회 작업을 가능하게 함
- ALGORITHM / LOCK 옵션을 이용해서 어떤 모드로 스키마 변경을 실행할지 결정할 수 있다.
- MySQL 서버는 old_alter_table 시스템 변수를 이용해서 alter table 명령이 온라인 ddl로 작동할지, 예전 방식 (테이블의 읽기/쓰기를 막고 스키마를 변경)으로 처리할지 결정
  - 기본 값은 OFF으로 자동으로 온라인 DDL이 활성화된다.
- ALTER TABLE 명령 실행 시 아래 순서로 스키마 변경에 적합한 알고리즘을 찾는다.
  1. ALGORITHM=INSTANT로 스키마 변경이 가능한지 확인 후 가능하다면 선택
  2. ALGORITHM=INPLACE로 스키마 변경이 가능한지 확인 후 가능하다면 선택
  3. ALGORITHM=COPY 알고리즘선택
- 스키마 변경 알고리즘의 우선순위가 낮을수록 MySQL 서버는 스키마 변경을 위해서 더 많은 잠금과 작업을 필요로 함 -> 서버의 부하도 많이 발생
  - INSTANT
    - 테이블의 데이터는 전혀 변경하지 않고, 메타데이터만 변경하고 작업 완료
    - 레코드의 수와 무관하게 작업 시간 매우 짧음
    - 스키마 변경도중 테이블의 읽기/쓰기는 대기하지만 변경 시간이 짧으므로 다른 커넥션에 영향 크게 없음
  - INPLACE
    - 임시 테이블로 데이터를 복사하지 않고 스키마 변경을 실행
    - 내부적으로 테이블의 리빌드를 실행할 수 있음
      - 레코드의 복사 작업은 없지만 테이블의 크기에 따라 많은 시간 소요
    - 스키마 변경도중에도 테이블의 읽기/쓰기 가능
      - 최초 시작/종료 시점에는 테이블의 읽기/쓰기가 불가능하지만 매우 짧은 시간이므로 다른 커넥션의 영향은 높지 않음
  - COPY
    - 변경된 스키마를 적용한 임시 테이블을 생성하고, 테이블의 레코드를 임시 테이블로 모두 복사한 후 임시 테이블을 RENAME해서 스키마 변경 완료
    - 테이블 읽기만 가능, 쓰기는 불가능
- 온라인 DDL은 알고리즘과 함께 잠금 수준도 명시 가능
  - algorithm, lock 옵션이 명시되지 않으면 MySQL 서버가 적절한 수준의 알고리즘과 잠금 수준을 선택한다.

  ```sql
    alter table salaries change to_date end_date date not null,
      algorithm=inplace, lock=none;
  ```
- INSTANT, COPY 알고리즘을 사용하는 경우 LOCK은 다음 3가지 중 하나를 명시
  - NONE: 아무런 잠금을 걸지 않음
  - SHARED: 읽기 잠금을 걸고 스키마 변경을 실행하기 때문에 스키마 변경 중 읽기는 가능, 쓰기는 불가
  - EXCLUSIVE: 쓰기 잠금을 걸고 스키마 변경을 실행하기 때문에 테이블의 읽기/쓰기 불가능
- INPLACE 알고리즘을 사용하는 경우 대부분의 잠금은 NONE이지만 가끔 SHARED 수준까지 설정해야 할 수 있음

### 온라인 처리 가능한 스키마 변경
- MySQL 서버의 모든 스키마 변경 작업이 온라인으로 가능한 것이 아니기 때문에 필요한 스키마 변경 작업의 형태가 온라인으로 처리될 수 있는지, 테이블의 읽고 쓰기가 대기하게 되는지 확인한 후 실행하는 것이 좋음
- MySQL 8.0.21 버전의 지원 사항
  [!img](./img/인덱스변경.png)
  [!img](./img/컬럼%20변경.png)
  [!img](./img/가상%20컬럼%20변경.png)
  [!img](./img/외래키%20변경.png)
  [!img](./img/테이블%20변경.png)
  [!img](./img/테이블%20스페이스%20변경.png)
  [!img](./img/파티션%20변경.png)
- ALTER TABLE 문장에 LOCK, ALGORITHM절을 명시해서 온라인 스키마 변경의 처리 알고리즘을 강제할 수 있음
  ```sql
    alter table employees drop primary key, algorithm=instant;
    alter table employees drop primary key, algorithm=inplace, lock=none;
    alter table employees drop primary key, algorithm=copy, lock=shared;
    alter table employees add primary key(emp_no), algorithm=inplace, lock=none;
  ```
  - 아래 순서로 algorithm, lock 옵션을 시도하면서 해당 알고리즘이 지원되는지 확인
    1. algorithm=instant 옵션으로 스키마 변경 시도
    2. 실패하면 algorithm=inplace, lock=none 옵션으로 스키마 변경 시도
    3. 실패하면 algorithm=inplace, lock=shared 옵션으로 스키마 변경 시도
    4. 실패하면 algorithm=copy, lock=shared 옵션으로 스키마 변경 시도
    5. 실패하면 algorithm=copy, lock=exclusive 옵션으로 스키마 변경 시도

### INPLACE 알고리즘
- 임시 테이블로 레코드를 복사하지는 않더라도 내부적으로 테이블의 모든 레코드를 리빌드해야 하는 경우가 많다.
  - 이럴 경우 MySQL 서버에서 진행되는 과정
    1. INPLACE 스키마 변경이 지원되는 스토리지 엔진의 테이블인지 확인
    2. INPLACE 스키마 변경 준비
      - 스키마 변경에 대한 정보를 준비해서 온라인 DDL 작업동안 변경되는 데이터를 추적할 준비
    3. 테이블 스키마 변경 및 새로운 DML 로깅
      - 실제 스키마 변경을 수행
      - 작업이 수행되는 동안은 다른 커넥션의 DML작업이 대기하지 않음
    4. 로그 적용
      - 온라인 DDL 작업동안 수집된 DML 로그를 테이블에 적용
    5. INPLACE 스키마 변경 완료 (COMMIT)
  - 2, 4 단계에서는 잠깐동안의 배타적 잠금이 필요, 다른 커넥션의 DML들은 대기
  - 3 단계에서는 다른 커넥션의 DML 작업이 대기 없이 즉시 처리됨

### 온라인 DDL의 실패 케이스
- 온라인 DDL이 INSTANT 알고리즘을 사용하는 경우 거의 시작과 동시에 작업이 완료되기 때문에 작업도중 실패할 가능성이 거의 없음
- INPLACE 알고리즘으로 실행되는 경우 내부적으로 테이블 리빌드 과정과 최종 로그 적용 과정이 필요해서 실패할 가능성이 상대적으로 높음
  - 몇 시간 동안 실행되던 온라인 DDL이 실패하면 상당한 자원과 시간 낭비
- 최대한 온라인 DDL이 실패할 가능성을 낮추는 것이 좋음
  - ALTER TABLE 명령이 장시간 실행되고 동시에 다른 커넥션에서 DML이 많이 실행되는 경우 or 온라인 변경 로그의 공간이 부족한 경우 온라인 스키마 변경 작업은 실패
  - ALTER TABLE 명령이 실행되는 동안 이전 버전의 테이블 구조에서는 문제가 안되지만 변경 이후의 테이블 구조에는 적합하지 않은 레코드가 INSERT되거나 UPDATE되었다면 마지막 과정에서 실패
  - 스키마 변경을 위해서 필요한 잠금 수준보다 낮은 잠금 옵션이 사용된 경우
  - 온라인 스키마 변경은 LOCK=NONE 으로 실행되더라도 변경 작업의 처음과 마지막 과정에서 잠금이 필요한데 획득하지 못하여 타임아웃이 발생하여 실패
  - 온라인으로 인덱스를 생성하는 작업의 경우 정렬을 위해 tmpdir 시스템 변수에 설정된 디스크 임시 디렉터리의 공간이 부족한 경우 실패

### 온라인 DDL 진행 상황 모니터링
- 온라인 DDL을 포함한 모든 ALTER TABLE 명령은 MySQL 서버의 performance_schema를 통해 진행 상황을 모니터링할 수 있다.
- performance_schema 옵션이 활성화되어야 함
  - MySQL 서버의 performance_schema 시스템 변수가 가장 먼저 ON으로 활성화되어야 함

```sql
  -- 시스템 변수 활성화 (MySQL 서버 재시작 필요)
  set global performance_schema=on;

  -- 'stage/innodb/alter%' instrument 활성화
  update performance_schema.setup_instruments
    set enabled='YES', timed='YES'
  where name like 'stage/innodb/alter%';

  -- '%stage%' consumer 활성화
  update performance_schema.setup_consumers
    set enabled='YES'
  where name like '%stage%';
```
- 스키마 변경 작업의 진행 상황은 performance_schema.events_stages_surrent 테이블을 통해 확인할 수 있는데, 실행 중인 스키마 변경 종류에 따라 기록되는 내용이 조금씩 달라진다.
- 온라인 DDL이 아닌 전통적인 COPY 알고리즘으로 스키마 변경이 진행되는 경우
  ```sql
    alter table salaries drop primary key, algorithm=copy, lock=shared;
    select event_name, work_completed, work_estimated
    from performance_schema.events_stages_current;
  ```
  ![img](./img/performance_schema_events_stages_current.png)
- 스키마 변경 작업이 온라인 DDL로 실행되는 경우 다양한 상태를 보여줌
  - 온라인 DDL이 단계별로 event_name 컬럼의 값을 달리해서 보여주기 때문

![img](./img/온라인DDL.png)
- work_estimated, work_completed 컬럼의 값을 비교해보면 alter table의 진행 상황을 예측할 수 있음
  - work_estimated 값은 예측치라서 alter table이 진행되면서 조금씩 변경될 수 있음

## 데이터베이스 변경
- MySQL에서 하나의 인스턴스는 1개 이상의 DB를 가질 수 있다.
- 다른 RDBMS에서는 스키마와 DB를 구문해서 관리, MySQL 서버에서는 스키마와 DB는 동격의 개념이다.
  - MySQL 서버에서는 굳이 스키마를 명시적으로 사용하지는 않음

### 데이터베이스 생성
```sql
  create database [if not exists] employees;
  create database [if not exists] employees character set utf8mb4;
  create database [if not exists] employees character set utf8mb4 collate utf8mb4_general_ci;
```
- 1번은 기본 문자집합/콜레이션으로 DB를 생성한다.
  - MySQL 서버의 character_set_server 시스템 변수에 정의된 문자 집합을 사용
- 2, 3번은 별도의 문자 집합과 콜레이션이 지정된 DB를 생성한다.
- 이미 동일 이름의 DB가 있다면 위 DDL은 에러 -> `IF NOT EXISTS` 키워드 사용하면 DB가 없는 경우에만 생성, 있다면 무시

### 데이터베이스 목록
```sql
  show databases;
  show databases like '%emp%';
```
- 접속된 MySQL 서버가 갖고있는 DB 목록을 나열함
  - 권한이 있는 DB의 목록만 표시
- 2번은 emp라는 문자열을 포함한 DB 목록만 표시한다.

### 데이터베이스 선택
```sql
  use employees;
```
- DB를 선택하는 명령
- 별도로 DB를 명시하지 않고 테이블이나 프로시저의 이름만 명시하면 MySQL 서버는 현재 커넥션의 기본 DB에서 주어진 테이블이나 프로시저를 검색한다.
- use를 사용하지 않고 다른 DB의 테이블이나 프로시저를 사용하려면 앞에 DB 이름을 명시해야 한다.
  ```sql
    select * from employees.departments;
  ```

### 데이터베이스 속성 변경
```sql
  alter database employees character set=euckr;
  alter database employees character set=euckr collate=euckr_korean_ci;
```
- DB를 생성할때 지정했었던 문자 집합이나 콜레이션을 변경한다.

### 데이터베이스 삭제
```sql
  drop database [if exists] employees;
```
- DB를 삭제한다.
- DB가 없다면 에러발생 -> `IF EXISTS` 키워드 사용하면 DB가 있는 경우에만 삭제, 아니면 무시

## 테이블 스페이스 변경
- MySQL 서버에는 전통적으로 테이블별로 전용의 테이블스페이스를 사용했다.
- InnoDB 스토리지 엔진의 시스템 테이블 스페이스만 제너럴 테이블스페이스를 사용했다.
  - 제너럴 테이블스페이스는 여러 테이블의 데이터를 한꺼번에 저장하는 테이블스페이스를 의미
- MySQL 8.0 부터 MySQL 서버에도 사용자 테이블을 제너럴 테이블스페이스로 저장하는 기능이 추가되고 테이블스페이스를 관리하는 DDL 명령들이 추가됨
  - MySQL 8.0에서도 제너럴 테이블스페이스는 여러가지 제약사항을 가짐
    - 파티션 테이블은 제너럴 테이블스페이스를 사용하지 못함
    - 복제 소스와 레플리카 서버가 동일 호스트에서 실행되는 경우 ADD DATAFILE 문장은 사용 불가
    - 테이블 암호화(TDE)는 테이블스페이스 단위로 설정됨
    - 테이블 압축 가능 여부는 테이블스페이스의 블록 사이즈와 InnoDB 페이지 사이즈에 의해 결정됨
    - 특정 테이블을 삭제해도 디스크 공간이 운영체제로 반납되지 않음
  - MySQL 8.0에서 사용자 테이블이 제너럴 테이블스페이스를 이용할 수 있게 개선된 이유 (장점)
    - 제너럴 테이블스페이스를 사용하면 파일 핸들러를 최소화함
    - 테이블스페이스 관리에 필요한 메모리 공간을 최소화함
  - 이 장점들은 테이블의 갯수가 매우 많은 경우에 유용함
  - innodb_file_per_table 시스템 변수로 테이블이 개별 테이블스페이스를 사용할지, 제너럴 테이블스페이스를 사용할지 제어할 수 있음
    - MySQL 8.0에서의 기본값은 ON이므로 테이블은 자동으로 개별 테이블스페이스를 사용한다.
