[9.3.1 옵티마이저 스위치 옵션](#931-옵티마이저-스위치-옵션)
- [9.3.1.1 MRR과 배치 키 액세스 (mrr & batched_key_access)](#9311-mrr과-배치-키-액세스-mrr--batched_key_access)
- [9.3.1.2 블록 네스티드 루프 조인 (block_nested_loop)](#9312-블록-네스티드-루프-조인-block_nested_loop)
  - [네스티드 루프 vs 블록 네스티드 루프](#네스티드-루프-vs-블록-네스티드-루프)
- [9.3.1.3 인덱스 컨디션 푸시다운 (index_condition_pushdown)](#9313-인덱스-컨디션-푸시다운-index_condition_pushdown)
- [9.3.1.4 인덱스 확장 (use_index_extensions)](#9314-인덱스-확장-use_index_extensions)
- [9.3.1.5 인덱스 머지 (index_merge)](#9315-인덱스-머지-index_merge)
- [9.3.1.6 인덱스 머지 - 교집합 (index_merge_intersection)](#9316-인덱스-머지---교집합-index_merge_intersection)
- [9.3.1.7 인덱스 머지 - 합집합 (index_merge_union)](#9317-인덱스-머지---합집합-index_merge_union)
- [9.3.1.8 인덱스 머지 - 정렬 후 합집합 (index_merge_sort_union)](#9318-인덱스-머지---정렬-후-합집합-index_merge_sort_union)
- [9.3.1.9 세미 조인 (semijoin)](#9319-세미-조인-semijoin)
- [9.3.1.10 테이블 풀-아웃 (Table Pull-out)](#93110-테이블-풀-아웃-table-pull-out)

# 9.3.1 옵티마이저 스위치 옵션
- optimizer_switch 시스템 변수로 제어
- 글로벌, 세션별 모두 설정할 수 있어서 MySQL 서버 전체적으로 또는 현재 커넥션에 대해 설정할 수 있음

## 9.3.1.1 MRR과 배치 키 액세스 (mrr & batched_key_access)
- MRR: Multi-Range Read
- MySQL 서버에서 지금까지 지원하던 조인 방식은 드라이빙 테이블의 레코드를 한 건 읽어서 드리븐 테이블의 일치하는 레코드를 찾아서 조인 수행 - Nested Loop Join
- 조인 처리는 MySQL 엔진이 처리하지만 실제 레코드를 검색하고 읽는 부분은 스토리지 엔진이 담당
  - 드라이빙 테이블의 레코드 건별로 드리븐 테이블의 레코드를 찾으면 레코드를 찾고 읽는 스토리지 엔진에서는 아무런 최적화를 수행할 수 없음
  - 위 단점을 보완하기 위해 MySQL 서버는 조인 대상 테이블 중 하나로부터 레코드를 읽어서 조인 버퍼에 버퍼링한다.
  - 조인 버퍼에 리코드가 가득 차면 MySQL 엔진은 버퍼링된 레코드를 스토리지 엔진으로 한 번에 요청한다.
  - 이렇게 함으로써 스토리지 엔진은 읽어야 할 레코드들을 데이터 페이지에 정렬된 순서로 접근해서 디스크의 데이터 페이지 읽기를 최소화할 수 있다.
- MRR을 응용해서 실행되는 조인 방식을 BKA (Batched Key Access) 조인이라고 한다.
  - 부가적인 정렬 작업이 필요한 단점이 있어 기본적으로 BKA 조인 최적화는 비활성화 되어있다.

## 9.3.1.2 블록 네스티드 루프 조인 (block_nested_loop)
- 조인의 연결 조건이 되는 컬럼에 모두 인덱스가 있는 경우 사용되는 조인 방식
- ```sql
    EXPLAIN
      SELECT *
      FROM employees e
        INNER JOIN salaries s ON s.emp_no=e.emp_no
          AND s.from_date<=NOW()
          AND s.to_date>=NOW()
      WHERE e.first_name='Amor';
  ```
  ```cpp
    for (row1 IN employees) {
      for (row2 IN salaries) {
        if (condition_matched) return (row1, row2);
      }
    }
  ```
  - 중첩된 반복 명령을 사용하는 것처럼 작동한다고 해서 네스티드 루프 조인이라고 한다.
  - 레코드를 읽어서 다른 버퍼 공간에 저장하지 않고, 즉시 드리븐 테이블의 레코드를 찾아서 반환한다.
- 조인은 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하면서 처리한다.
  - 드라이빙 테이블은 한 번에 읽고, 드리븐 테이블은 여러 번 읽는다.
  - 드리븐 테이블의 조인 조건이 인덱스를 이용할 수 없다면 드리븐 테이블에서 연결되는 레코드를 찾기 위해 풀 테이블 스캔을 N번 해야한다. -> 쿼리가 상당히 느려짐
  - 옵티마이저는 최대한 드리븐 테이블의 검색이 인덱스를 사용할 수 있게 실행 계획을 수립한다.
  - 어떤 방식으로도 드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔을 피할 수 없다면 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리한다.
    - 여기서 사용되는 메모리의 캐시를 조인 버퍼라고 함
      - `join_buffer_size` 시스템 변수로 크기 제한
      - 조인이 완료되면 조인 버퍼는 바로 해제된다.
  - ```sql
      SELECT *
      FROM dept_emp de, employees e
      WHERE de.from_date>'1995-01-01' AND e.emp_no<109004;
    ```
    ![img](./img/9.9%20%EC%A1%B0%EC%9D%B8%20%EB%B2%84%ED%8D%BC%EB%A5%BC%20%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%20%EC%A1%B0%EC%9D%B8.png)
    1. dept_emp 테이블의 ix_fromdate 인덱스를 이용해서 `from_date>'1995-01-01'` 조건을 만족하는 레코드를 검색한다.
    2. 조인에 필요한 나머지 컬럼을 모두 dept_emp 테이블로부터 읽어서 조인 버퍼에 저장한다.
    3. employees 테이블의 PK를 이용해서 `emp_no<109004` 조건을 만족하는 레코드를 검색한다.
    4. 3에서 검색된 결과에 2에서 캐시된 조인 버퍼의 레코드를 결합해서 반환한다.
    - 쿼리의 실행 계획상으로 dept_emp 테이블이 드라이빙 테이블, employees 테이블이 드리븐 테이블이 된다.
    - 실제 드라이빙 테이블의 결과는 조인 버퍼에 담아두고, 드리븐 테이블을 먼저 읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식으로 처리된다.
    - 일반적으로 조인이 수행된 후 가져오는 결과는 드라이빙 테이블의 순서에 의해 결정되지만 조인 버퍼가 사용되는 조인에서는 결과의 정렬 순서가 흐트러질 수 있다.

### 네스티드 루프 vs 블록 네스티드 루프
- 조인 버퍼가 사용되는지 여부와 조인에서 드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인되는지
- `Block`이라는 단어가 사용되면 조인용으로 별도의 버퍼가 사용되었음을 의미
  - Extra에 `Using Join buffer` 메시지 표시

## 9.3.1.3 인덱스 컨디션 푸시다운 (index_condition_pushdown)
- MySQL 5.6 버전부터 도입된 기능
- ```sql
    ALTER TABLE employees ADD INDEX ix_lastname_firstname (last_name, first_name);

    SET optimizer_switch='index_condition_pushdown=off';
    SHOW VARIABLES LIKE 'optimizer_switch'
  ```
  ```sql
    SELECT * FROM employees WHERE last_name='Action' AND first_name LIKE '%sal';
  ```
  - `last_name='Action'` 조건은 `ix_lastname_firstname` 인덱스를 레인지 스캔으로 사용할 수 있다.
  - `first_name LIKE '%sal'` 조건은 인덱스 레인지 스캔을 사용할 수 없다.
    - 위 쿼리로는 인덱스의 특정 범위만 조회할 수 있는 조건이고, first_name LIKE '%sal' 조건은 데이터를 모두 읽은 후 하나씩 비교해야 한다.
  - 실행 계획의 Extra에는 `Using where` 메시지가 표시
    - `first_name LIKE '%sal'` 조건이 해당
  - 인덱스를 비교하는 작업은 실제 InnoDB 스토리지 엔진이 수행, 테이블의 레코드에서 first_name을 비교하는 작업은 MySQL 엔진이 수행
    - MySQL 5.5 까지는 인덱스를 범위 제한 조건으로 사용하지 못하는 조건을 MySQL -> InnODB 스토리지 엔진으로 전달하지 않았음 -> 불필요한 테이블 읽기가 수행되었음
    - MySQL 5.6 부터는 인덱스에 포함된 컬럼의 조건이 있다면 모두 스토리지 엔진으로 전달할 수 있게 핸들러 API가 개선되었음 -> 필요한 테이블 읽기만 수행함
  - `SET optimizer_switch='index_condition_pushdown=on';`으로 변경 후 실행 계획 확인
    - Extra에 `Using index condition` 메시지가 표시된다.

## 9.3.1.4 인덱스 확장 (use_index_extensions)
- InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 PK를 활용할 수 있게 할지 결정하는 옵티마이저 옵션
- InnoDB 스토리지 엔진은 PK를 클러스터링 키로 생성하여 모든 세컨더리 인덱스를 리프 노드에 PK 값을 가진다.
- ```sql
    CREATE TABLE dept_emp (
      emp_no INT NOT NULL,
      dept_no CHAR(4) NOT NULL,
      from_date DATE NOT NULL,
      to_date DATE NOT NULL,
      PRIMARY KEY (dept_no, emp_no),
      KEY ix_fromdate (from_date)
    ) ENGINE=InnoDB;
  ```
  - ix_fromdate 인덱스는 (from_date, dept_no, emp_no) 조합으로 인덱스를 생성한 것과 흡사하게 작동할 수 있다.
  - MySQL 서버가 업그레이드되면서 옵티마이저는 ix_fromdate 인덱스의 마지막에 PK 컬럼이 숨어있다는 것을 인지하고 실행 계획을 수립하도록 개선되었다.
  - ```sql
      -- key_len: 쿼리가 인덱스를 구성하는 컬럼 중에서 어느 부분까지 사용했는지 바이트 수로 표시
      EXPLAIN SELECT COUNT(*) FROM dept_emp WHERE from_date='1987-07-25' AND dept_no='d001';
      -- 19 바이트 표시, (from_date, dept_emp) 컬럼 사용

      EXPLAIN SELECT COUNT(*) FROM dept_emp WHERE from_date='1987-07-25';
      -- 3 바이트 표시, (from_date) 컬럼 사용
    ```
  - PK가 세컨더리 인덱스에 포함되어 있어서 ORDER BY 정렬 작업도 인덱스를 활용해서 처리한다.
    - ```sql
        EXPLAIN SELECT * FROM dept_emp WHERE from_date='1987-07-25 ORDER BY dept_no';
        -- Extra에 `Using Filesort`가 표시되지 않음 -> 별도의 정렬 작업 없이 인덱스 순서대로 레코드를 읽음
      ```

## 9.3.1.5 인덱스 머지 (index_merge)
- 인덱스를 이용한 쿼리 실행 시 대부분의 옵티마이저는 테이블별로 하나의 인덱스만 사용하도록 실행 계획을 수립한다.
- 인덱스 머지 실행 계획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해서 쿼리를 커리한다.
  - 쿼리에 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고, 그 조건을 만족하는 레코드 건수가 많을 것으로 예상될 때 MySQL 서버는 인덱스 머지 실행 계획을 선택한다.
- 3개의 세부 실행 계획
  - index_merge_intersection
  - index_merge_sort_union
  - index_merge_union

## 9.3.1.6 인덱스 머지 - 교집합 (index_merge_intersection)
```sql
  EXPLAIN SELECT *
  FROM employees
  WHERE first_name='Georgi' AND emp_no BETWEEN 10000 AND 20000;

  -- 두 조건을 모두 만족하는 레코드: 14
  -- first_name='Georgi' 조건을 만족하는 레코드: 253
  -- emp_no BETWEEN 10000 AND 20000 조건을 만족하는 레코드: 10000
```
- Extra에 `Using intersect` 표시
- first_name, emp_no 컬럼 모두 각각의 인덱스를 갖고 있다.
- 어떤 조건을 사용하더라도 인덱스를 사용할 수 있다. -> 옵티마이저는 두 인덱스를 모두 사용해서 쿼리를 처리하기로 결정
- 인덱스를 각각 검색해서 그 결과의 교집합에 해당하는 레코드들만 반환한다.
- 인덱스 머지 실행 계획이 아니었다면
  - `first_name='Georgi'` 조건만 인덱스를 사용했다면 일치하는 레코드를 검색한 다음, 데이터 페이지에서 레코드를 찾고 emp_no 컬럼의 조건에 일치하는 레코드들만 반환하는 형태로 처리
    - 253개의 데이터 페이지 읽기를 해서 14건만 반환
  - `emp_no BETWEEN 10000 AND 20000` 조건만 인덱스를 사용했다면 PK를 이용해서 레코드를 검색한 다음 first_name 조건에 일치하는 레코드들만 반환하는 형태로 처리
    - 10000개의 데이터 페이지를 읽고 14건만 반환
  - 두 작업 모두 비효율이 매우 큰 상황에서 옵티마이저는 각 인덱스를 검색한 두 결과의 교집합만 찾아서 반환한다.
- ```sql
    -- MySQL 서버 전체적으로 index_merge_intersection 최적화 비활성화
    SET GLOBAL optimizer_switch='index_merge_intersection=off'

    -- 현재 커넥션에 대해 index_merge_intersection 최적화 비활성화
    SET SESSION optimizer_switch='index_merge_intersection=off'

    -- 현재 쿼리에서만 index_merge_intersection 최적화 비활성화
    EXPLAIN
    SELECT SET_VAR(optimizer_switch='index_merge_intersection=off')
    FROM employees
    WHERE first_name='Georgi' AND emp_no BETWEEN 10000 AND 20000;
  ```

## 9.3.1.7 인덱스 머지 - 합집합 (index_merge_union)
```sql
  SELECT *
  FROM employees
  WHERE first_name='Matt' OR hire_date='1987-03-31';
```
- Extra에 `Using union` 표시
- WHERE절에 사용된 2개 이상의 조건이 각각의 인덱스를 사용하되 `OR` 연산자로 연결된 경우에 사용되는 최적화
- first_name, hire_date 컬럼 모두 인덱스를 사용할 수 있다.
- 인덱스를 각각 검색해서 나온 결과에서 중복을 제거하기 위해 정렬 작업을 하지 않는다.
  - ```sql
      SELECT * FROM employees WHERE first_name='Matt';
      SELECT * FROM employees WHERE hire_date='1987-03-31';
    ```
  - 우선 두 검색 결과는 PK 기준으로 정렬되어 있다.
  - 두 검색 결과에서 하나씩 가져와서 우선순위 큐를 이용해서 중복을 제거한다.

## 9.3.1.8 인덱스 머지 - 정렬 후 합집합 (index_merge_sort_union)
```sql
  EXPLAIN
  SELECT *
  FROM employees
  WHERE first_name='Matt'
    OR hire_date BETWEEN '1987-03-01' AND '1987-03-31';
```
```sql
  SELECT * FROM employees WHERE first_name='Matt';
  SELECT * FROM employees WHERE hire_date BETWEEN '1987-03-01' AND '1987-03-31';
```
- Extra에 `Using sort_union` 표시
- 두 결과 집합의 중복을 제거하기 위해 정렬이 필요한 경우 MySQL 서버는 인덱스 머지 최적화의 `Sort union` 알고리즘을 사용한다.
- 첫 번째 쿼리는 emp_no로 정렬되지만 두 번째 쿼리 결과는 emp_no 컬럼으로 정렬되지 않는다.
  - 우선순위 큐 사용이 불가능해서 중복제거를 위해 각 집합을 emp_no로 정렬한 다음 중복 제거를 수행한다.

## 9.3.1.9 세미 조인 (semijoin)
```sql
  SELECT *
  FROM employees e
  WHERE e.emp_no IN
    (SELECT de.emp_no FROM dept_emp de WHERE de.from_date='1995-01-01');
```
- 실제 조인을 수행하지는 않고, 다른 테이블에서 조건에 일치하는 레코드가 있는지만 체크하는 형태의 쿼리
- MySQL 5.7 서버는 전통적으로 세미 조인 형태의 쿼리를 최적화하는 부분이 취약했다.
  - 세미 조인 최적화 기능이 없었을 때는 employees 테이블을 풀 스캔하면서 한 건씩 서브쿼리 조건에 일치하는지 비교했다.
  - MySQL 8.0 버전은 `SET SESSION optimizer_switch='semijoin=off'` 명령으로 이 방식을 확인할 수 있다.
    - 테스트가 완료되면 `SET optimizer_switch='default'` 명령으로 기본 값으로 되돌리자.
- 세미 조인 vs 안티 세미 조인
  - `= (sub query)`, `IN (sub query)` 형태의 세미 조인 쿼리에 대한 최적화
    - 세미 조인 최적화
      - MySQL 8.0 버전부터는 세미 조인 쿼리의 성능을 개선하기 위한 최적화 전략
      - Table Pull-out
      - Duplicate Weed-out
      - First Match
      - Loose Scan
      - Materialization
    - IN-to-EXISTS 최적화
    - MATERIALIZATION 최적화
  - `<> (sub query)`, `NOT IN (sub query)` 형태의 안티 세미 조인 쿼리에 대한 최적화
    - IN-to-EXIST 최적화
    - MATERIALIZATION 최적화

## 9.3.1.10 테이블 풀-아웃 (Table Pull-out)
- 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 가져와서 쿼리를 조인 쿼리로 재작성하는 형태의 최적화
- 서브쿼리 최적화가 도입되기 이전에 수동으로 쿼리를 튜닝하던 대표적인 방법
- ```sql
    EXPLAIN
    SELECT * FROM employees e
    WHERE e.emp_no IN (SELECT de.emp_no FROM dept_emp de WHERE de.dept_no='d009');
  ```
  - id 컬럼의 값이 같게 나옴 -> 두 테이블이 서브쿼리 형태가 아닌 조인으로 처리되었음
  - Extra에 메시지가 표시되지 않는다.
    - 실행 계획에서 해당 테이블을의 id 컬럼 값이 같은지 확인한다.
    - 더 정확한 방법으로는 SHOW WARNINGS 명령으로 MySQL 옵티마이저가 재작성한 쿼리를 살펴보는 것
- Table pullout 최적화는 모든 형태의 서브쿼리에서 사용될 수 있는건 아님
  - Table pullout 최적화는 세미 조인 서브쿼리에서만 사용 가능하다.
  - Table pullout 최적화는 서브쿼리 부분이 UNIQUE 인덱스나 PK 룩업으로 결과가 1건인 경우에만 사용 가능하다.
  - Table pullout이 적용된다고 해도 기존 쿼리에서 가능했던 최적화 방법이 사용 불가능한 것은 아니므로 MySQL에서는 가능하다면 Table pullout 최적화를 최대한 적용한다.
  - Table pullout 최적화는 서브쿼리의 테이블을 아우터 쿼리로 가져와서 조인으로 풀어쓰는 최적화를 수행하는데, 만약 서브쿼리의 모든 테이블이 아우터 쿼리로 끄집어낼 수 있다면 서브쿼리 자체는 없어진다.
  - MySQL에서는 `최대한 서브쿼리를 조인으로 풀어서 사용해라`라는 튜닝 가이드가 많은데, Table pullout 최적화는 이를 그대로 실행한 것이다. 이제부터는 조인으로 풀어서 사용할 필요가 없다.
