[9.2.1 풀 테이블 스캔과 풀 인덱스 스캔](#921-풀-테이블-스캔과-풀-인덱스-스캔)

[9.2.2 병렬 처리](#922-병렬-처리)

[9.2.3 ORDER BY 처리 (Using filesort)](#923-order-by-처리-using-filesort)
- [9.2.3.1 소트 버퍼](#9231-소트-버퍼)
- [9.2.3.2 정렬 알고리즘](#9232-정렬-알고리즘)
  - [9.2.3.2.1 싱글 패스 정렬 방식](#92321-싱글-패스-정렬-방식)
  - [9.2.3.2.2 투 패스 정렬 방식](#92322-투-패스-정렬-방식)
- [9.2.3.3 정렬 처리 방법](#9233-정렬-처리-방법)
  - [9.2.3.3.1 인덱스를 이용한 정렬](#92331-인덱스를-이용한-정렬)
  - [9.2.3.3.2 조인의 드라이빙 테이블만 정렬](#92332-조인의-드라이빙-테이블만-정렬)
  - [9.2.3.3.3 임시 테이블을 이용한 정렬](#92333-임시-테이블을-이용한-정렬)
  - [9.2.3.3.4 정렬 처리 방법의 성능 비교](#92334-정렬-처리-방법의-성능-비교)
    - [9.2.3.3.4.1 스트리밍 방식](#923341-스트리밍-방식)
    - [9.2.3.3.4.2 버퍼링 방식](#923342-버퍼링-방식)
- [9.2.3.4 정렬 관련 상태 변수](#9234-정렬-관련-상태-변수)

[9.2.4 GROUP BY 처리](#924-group-by-처리)
- [9.2.4.1 인덱스 스캔을 이용하는 GROUP BY (타이트 인덱스 스캔)](#9241-인덱스-스캔을-이용하는-group-by-타이트-인덱스-스캔)
- [9.2.4.2 루스 인덱스 스캔을 이용하는 GROUP BY](#9242-루스-인덱스-스캔을-이용하는-group-by)
- [9.2.4.3 임시 테이블을 사용하는 GROUP BY](#9243-임시-테이블을-사용하는-group-by)

[9.2.5 DISTINCT 처리](#925-distinct-처리)
- [9.2.5.1 SELECT DISTINCT](#9251-select-distinct)
- [9.2.5.2 집합 함수와 함께 사용된 DISTINCT](#9252-집합-함수와-함께-사용된-distinct)

[9.2.6 내부 임시 테이블 활용](#926-내부-임시-테이블-활용)
- [9.2.6.1 메모리 임시 테이블과 디스크 임시 테이블](#9261-메모리-임시-테이블과-디스크-임시-테이블)
- [9.2.6.2 임시 테이블이 필요한 쿼리](#9262-임시-테이블이-필요한-쿼리)
- [9.2.6.3 임시 테이블이 디스크에 생성되는 경우](#9263-임시-테이블이-디스크에-생성되는-경우)
- [9.2.6.4 임시 테이블 관련 상태 변수](#9264-임시-테이블-관련-상태-변수)

# 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
- 풀 테이블 스캔: 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업
- MySQL 옵티마이저는 아래 조건이 일치할 때 주로 풀 테이블 스캔을 선택한다.
  - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우 (일반적으로 테이블이 페이지 1개로 구성된 경우)
  - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 해도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- 테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 상당히 많은 디스크 읽기가 필요
  - 대부분 DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있음
  - MySQL은 풀 테이블 스캔 시 몇 개씩 페이지를 읽어올 지 설정하는 시스템 변수가 없음
    - MySQL은 풀 테이블 스캔을 실행할 때 디스크로부터 페이지를 하나씩 읽어오는 것은 아님 (InnoDB)
    - 처음 몇 개의 데이터 페이지는 포그라운드 스레드, 특정 시점부터는 백그라운드 스레드가 담당
      - Read ahead: 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버러 풀에 가져다 두는 것
        - 풀 테이블 스캔, 풀 인덱스 스캔에서 모두 사용됨
      - 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 (Read ahead) 작업이 자동으로 시작된다.
        - 백그라운드 스레드는 한 번에 최대 64페이지까지 읽음

# 9.2.2 병렬 처리
- MySQL 8.0 버전부터는 용도가 한정되어 있긴 하지만 처음으로 쿼리의 병렬 처리가 가능해졌다.
  - 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리함
  - `innodb_parallel_read_threads` 시스템 변수를 이용해서 최대 몇 개의 스레드를 이용할지 변경
  - 아무런 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있다.
  - 병렬 처리용 스레드 갯수가 늘어날수록 쿼리 처리에 걸리는 시간이 줄어든다.
    - 서버에 장착된 CPU의 코어 갯수를 넘어서면 오히려 성능이 떨어질 수 있음

# 9.2.3 ORDER BY 처리 (Using filesort)
- 정렬을 처리하는 방법
  - 인덱스 이용
    - 장점
      - INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬되어 있어서 순서대로 읽기만 하면 된다 -> 빠르다
    - 단점
      - INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다.
      - 인덱스때문에 디스크 공간이 더 많이 필요하다.
      - 인덱스의 갯수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요하다.
  - Filesort 이용
    - 장점
      - 인덱스를 생성하지 않아도 되므로 인덱스의 단점이 장점이 된다.
      - 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다.
    - 단점
      - 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.
- 모든 정렬을 인덱스를 이용하도록 튜닝하기란 거의 불가능
  - 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
  - GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
  - UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬하는 경우
  - 랜덤하게 결과 레코드를 가져오는 경우

## 9.2.3.1 소트 버퍼
- MySQL이 정렬을 수행하기 위해 할당받는 별도의 메모리 공간
- 정렬이 필요한 경우에만 할당된다.
- 쿼리의 실행이 완료되면 즉시 시스템으로 반납
- 버퍼의 크기는 레코드의 크기에 따라 가변적으로 증가, 최대 사용 가능한 공간을 sort_buffer_size 시스템 변수로 설정
- 정렬해야 할 레코드가 버퍼로 할당된 공간보다 크다면?
  - MySQL은 정렬해야 할 레코드를 여러 조각으로 나눠서 처리
  - 임시 저장을 위해 디스크를 사용한다.
    1. 메모리의 소트 버퍼에서 정렬 수행
    2. 결과를 임시로 디스크에 기록
    3. 다음 레코드를 가져옴
    4. 1 ~ 3 반복
    - 이 병합 작업을 멀티 머지(Multi-merge)라고 표현

## 9.2.3.2 정렬 알고리즘
- 싱글 패스 VS 투 패스 방식
- 정렬을 수행하는 쿼리가 어떤 정렬 방식을 사용하는지 옵티마이저 트레이스 기능으로 확인
- MySQL 서버의 정렬 방식
  - 투 패스
    - <sort_key, rowid>: 정렬 키와 레코드의 rowid만 가져와서 정렬하는 방식
  - 싱글 패스
    - <sort_key, additional_fields>: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드의 컬럼들은 고정 사이즈로 메모리 저장
    - <sort_key, packed_additional_fields>: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드의 컬럼들은 가변 사이즈로 메모리 저장
      - MySQL 5.7부터 도입, 정렬을 위한 메모리 공간의 효율적인 사용을 위해 추가
- 일반적으로는 싱글 패스 정렬 방식을 사용
- 투 패스 정렬 방식을 사용하는 경우
  - 레코드의 크기가 max_length_for_sort_data 시스템 변수 값보다 클 때
  - BLOB이나 TEXT 타입의 컬럼이 SELECT 대상에 포함될 때

### 9.2.3.2.1 싱글 패스 정렬 방식
![img](./img/9.2%20%EC%8B%B1%EA%B8%80%20%ED%8C%A8%EC%8A%A4%20%EC%A0%95%EB%A0%AC%20%EB%B0%A9%EC%8B%9D.png)
  - 레코드 전체를 소트 버퍼에 담아서 정렬을 수행하는 방식
  - ```sql
    SELECT emp_no, first_name, last_name
    FROM employees
    ORDER BY first_name;
    ```
  - 정렬에 필요하지 않은 컬럼까지 읽어서 소트 버퍼에 담는다.
    - 투 패스 정렬 방식에 비해 더 많은 소트 버퍼 공간이 필요함
  - 정렬된 결과를 그대로 클라이언트에 전달한다.

### 9.2.3.2.2 투 패스 정렬 방식
![img](./img/9.3%20%ED%88%AC%20%ED%8C%A8%EC%8A%A4%20%EC%A0%95%EB%A0%AC%20%EB%B0%A9%EC%8B%9D.png)
  - 정렬 기준 컬럼만 소트 버퍼에 담아서 정렬을 수행하는 방식
  - 싱글 패스 정렬 방식이 도입되기 이전부터 사용
  - MySQL 8.0에도 특정 조건에서는 이 방식을 사용
  - ```sql
    SELECT emp_no, first_name, last_name
    FROM employees
    ORDER BY first_name;
    ```
  - 정렬에 필요한 first_name, PK인 emp_no만 가져와서 소트 버퍼에 담는다.
  - 정렬된 순서대로 employees 테이블을 한번 더 읽어서 나머지 컬럼도 가져온다.
    - 테이블을 두 번 읽어야하는 단점이 있음
  - 최종 결과를 클라이언트에 전달한다.

## 9.2.3.3 정렬 처리 방법
> ORDER BY 사용 시 정렬이 처리되는 방법
- 인덱스를 사용한 정렬
  - 실행 계획의 Extra 컬럼 내용 없음
- 조인에서 드라이빙 테이블만 정렬
  - "Using filesort" 메시지 표시
- 조인에서 조인 결과를 임시 테이블로 저장 후 정렬
  - "Using temporary; Using filesort" 메시지 표시
- 먼저 옵티마이저는 정렬 처리를 위해 인덱스를 이용할 수 있는지 검토한다.
- 인덱스 이용이 가능하면 별도의 Filesort 과정 없이 인덱스를 순서대로 읽어서 결과 반환
- 인덱스 이용이 불가능하면 WHERE 조건에 일치하는 레코드를 검색해서 정렬 버퍼에 저장하면서 처리
- MySQL 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 아래 2가지 방법 중 하나를 선택
  - 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
  - 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬 수행

### 9.2.3.3.1 인덱스를 이용한 정렬
> 반드시 ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.<br/>
또한 WHERE 절에 첫 번째로 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.

![img](./img/9.4%20%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%A5%BC%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20%EC%A0%95%EB%A0%AC.png)
- 실제 인덱스의 값이 정렬되어 있기 때문에 순서대로 읽기만 하면 된다.
- MySQL 엔진에서 별도의 정렬을 위한 추가 작업을 수행하지는 않는다.
- 인덱스를 사용한 정렬이 가능한 이유
  - B-Tree 인덱스가 키 값으로 정렬되어 있기 때문
  - 조인이 네스티드-루프 방식으로 실행되기 때문
- 조인이 사용된 쿼리의 실행 계획에 조인 버퍼가 사용되면 순서가 흐트러질 수 있어서 주의해야 함

### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬
> 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것<br/>
조인에서 첫 번째로 읽히는 테이블의 컬럼만으로 ORDER BY 절을 작성해야 한다.
```sql
  SELECT *
  FROM employees e, salaries s
  WHERE s.emp_no = e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100010
  ORDER BY e.last_name;
```
- WHERE절이 2가지 조건을 갖추고 있기 때문에 옵티마이저는 employees 테이블을 드라이빙 테이블로 선택
  - WHERE절의 검색 조건은 employees 테이블의 PK를 이용해 검색하면 작업량을 줄일 수 있다.
  - salaries 테이블의 조인 컬럼인 emp_no 컬럼에 인덱스가 있다.
- 검색은 인덱스 레인지 스캔으로 처리할 수 있지만 ORDER BY절에 명시된 컬럼은 e.PK와 연관이 없으므로 인덱스를 이용한 정렬은 불가능하다.
- ORDER BY절의 정렬 기준 컬럼이 드라이빙 테이블에 포함된 컬럼임을 알 수 있다.
- 옵티마이저는 드라이빙 테이블만 검색해서 정렬을 먼저 수행하고 그 결과와 salaries 테이블을 조인한 것이다.

![img](./img/9.5%20%EC%A1%B0%EC%9D%B8%EC%9D%98%20%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B9%99%20%ED%85%8C%EC%9D%B4%EB%B8%94%EB%A7%8C%20%EC%A0%95%EB%A0%AC%20%EC%8B%A4%ED%96%89.png)
1. 인덱스를 이용해 `emp_no BETWEEN 100001 AND 100010` 조건을 만족하는 9건을 검색
2. 검색 결과를 `last_name` 컬럼으로 정렬을 수행 (Filesort)
3. 정렬된 결과를 순서대로 읽으면서 salaries 테이블과 조인을 수행해 86건의 최종 결과를 가져옴

### 9.2.3.3.3 임시 테이블을 이용한 정렬
> 2개 이상의 테이블을 조인해서 그 결과를 전부 임시 테이블에 넣어서 정렬하는 방식

![img](./img/9.6%20%EC%9E%84%EC%8B%9C%20%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%84%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20%EC%A0%95%EB%A0%AC.png)
- 위 2가지 방법보다 정렬할 레코드 건수가 많기 때문에 가장 느린 정렬 방법이다.
- ```sql
    SELECT *
    FROM employees e, salaries s
    WHERE s.emp_no=e.emp_no
      AND e.emp_no BETWEEN 100002 AND 100010
    ORDER BY s.salary;
  ```
- ORDER BY 절의 정렬 기준 컬럼이 s.salary이고, 정렬이 수행되기 전에 salaries 테이블을 읽어야하므로 이 쿼리는 조인된 데이터를 가지고 정렬할 수밖에 없다.
  - employees 테이블의 Extra 컬럼에 `Using temporary; Using filesort`가 표시된다.
  - 조인의 결과를 임시 테이블에 저장하고 그 결과를 다시 정렬했음을 의미

### 9.2.3.3.4 정렬 처리 방법의 성능 비교
- 주로 웹 서비스용 쿼리에서는 ORDER BY와 함께 LIMIT이 필수로 사용되는 경향이 있다.
- `ORDER BY` `GROUP BY` 같은 작업은 WHERE 조건을 만족하는 레코드를 LIMIT 건수만큼만 가져와서는 처리할 수 없다.
  - 조건을 만족하는 레코드를 모두 가져와서 정렬을 수행하거나 그루핑 작업을 실행해야만 `LIMIT`으로 제한할 수 있다.
- WHERE 조건이 아무리 인덱스를 잘 활용하도록 튜닝해도 잘못된 `ORDER BY` `GROUP BY` 때문에 쿼리가 느려지는 경우가 자주 발생한다.

#### 9.2.3.3.4.1 스트리밍 방식
> 서버쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될때마다 클라이언트로 전송해주는 방식
- 클라이언트는 쿼리를 요청하고 곧바로 원했던 첫 번째 레코드를 전달받는다.
- 클라이언트는 MySQL 서버가 일치하는 레코드를 찾는 즉시 전달받기 때문에 동시에 데이터의 가공 작업을 시작할 수 있다.
- 웹 서비스 같은 OLTP 환경에서는 쿼리의 요청에서부터 첫 번재 레코드를 전달받기까지의 응답 시간이 중요하다.
- LIMIT 처럼 건수를 제한하는 쿼리의 전체 실행 시간을 상당히 줄여준다.
- 이 쿼리에 LIMIT을 추가하면 전체적으로 가져오는 레코드 건수가 줄어들어서 마지막 레코드를 가져오기까지 시간을 줄여준다.
- `인덱스를 이용한 정렬 방식`이 해당

#### 9.2.3.3.4.2 버퍼링 방식
> `ORDER BY` `GROUP BY` 가 추가된 쿼리는 스트리밍이 불가능하다.<br/>
WHERE 조건에 일치하는 모든 레코드를 가져온 후에 정렬하거나 그루핑해서 차례대로 보내야하기 때문
- MySQL 서버에서 모든 레코드를 검색하고 정렬 작업을 하는동안 클라이언트는 아무것도 하지않고 기다려야 하기 때문에 응답 속도가 느려진다.
- LIMIT을 추가해도 성능 향상에 별로 도움이 되지 않는다.
- `조인의 드라이빙 테이블만 정렬`, `임시 테이블을 이용한 정렬 방식`이 해당

## 9.2.3.4 정렬 관련 상태 변수
- MySQL 서버는 처리하는 주요 작업에 대해서는 해당 작업의 실행 횟수를 상태 변수로 저장한다.
- 정렬과 관련해서도 지금까지 몇 건의 레코드나 정렬 처리를 수행했는지, 소트 버퍼 간의 병합 작업은 몇 번이나 발생했는지 확인할 수 있다.
- ```sql
    FLUSH STATUS;
    SHOW STATUS LIKE 'Sort%';
  ```
- `Sort_merge_passes`: 멀티 머지 처리 횟수
- `Sort_range`: 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
- `Sort_scan`: 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
- `Sort_rows`: 지금까지 정렬한 전체 레코드 건수

# 9.2.4 GROUP BY 처리
> ORDER BY와 같이 쿼리가 스트리밍된 처리를 할 수 없게 하는 처리 중 하나
- 인덱스를 사용하는 경우
  - 인덱스를 차례대로 읽는 인덱스 스캔 방법
  - 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔
- 인덱스를 사용하지 못하는 경우
  - 임시 테이블 사용

## 9.2.4.1 인덱스 스캔을 이용하는 GROUP BY (타이트 인덱스 스캔)
- 조인의 드라이빙 테이블에 속한 컬럼만 이용해 그루핑할 때 GROUP BY 컬럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리한다.
- 그룹 함수 등의 그룹값을 처리해야 해서 임시 테이블이 필요할 때도 있다.
- 이미 정렬된 인덱스를 읽는 것이므로 쿼리 실행 시점에 추가적인 정렬 작업이나 내부 임시 테이블은 필요하지 않다.
- 이 방식은 Extra 컬럼에 코멘트가 별도로 표시되지 않는다.

## 9.2.4.2 루스 인덱스 스캔을 이용하는 GROUP BY
- 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것
- 옵티마이저가 루스 인덱스 스캔을 사용할 때는 실행 계획의 Extra 컬럼에 `Using index for group-by` 코멘트가 표시된다.
- ```sql
    EXPLAIN
      SELECT emp_no
      FROM salaries
      WHERE from_date='1985-03-01'
      GROUP BY emp_no;
  ```
- salaries 테이블의 인덱스는 (emp_no, from_date)로 생성되어 있으므로 위 쿼리에서 WHERE 조건은 인덱스 레인지 스캔 접근 방식으로 이용할 수 없다.
- 하지만 이 쿼리의 실행 계획은 인덱스 레인지 스캔(range 타입)을 이용했으며, Extra 컬럼의 메시지에도 GROUP BY 처리까지 인덱스를 사용했다.
- MySQL 서버가 이 쿼리를 실행한 순서
  1. (emp_no, from_date) 인덱스를 차례대로 스캔하면서 `emp_no`의 첫 번째 유일한 값 `10001`을 찾는다.
  2. (emp_no, from_date) 인덱스에서 `emp_no`가 `10001`인 것 중에서 `from_date` 값이 `1985-03-01`인 레코드만 가져온다.
  3. (emp_no, from_date) 인덱스에서 `emp_no`의 그다음 유니크한 값을 가져온다.
  4. 3에서 결과가 더 없으면 처리를 종료, 있다면 2로 돌아가서 반복 수행한다.
- 루스 인덱스 스캔을 사용할 수 없는 쿼리 패턴
  ```sql
    -- MIN() MAX() 이외의 집합 함수가 사용됨
    SELECT col1, SUM(col2) FROM tb_test GROUP BY col1;

    -- GROUP BY에 사용된 컬럼이 인덱스 구성 컬럼의 왼쪽부터 일치하지 않음
    SELECT col1, col2 FROM tb_test GROUP BY col2, col3;

    -- SELECT 절의 컬럼이 GROUP BY와 일치하지 않음
    SELECT col1, col3 FROM tb_test GROUP BY col1, col2;
  ```

## 9.2.4.3 임시 테이블을 사용하는 GROUP BY
> GROUP BY의 기준 컬럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 경우 사용된다.
```sql
  EXPLAIN
    SELECT e.last_name, AVG(s.salary)
    FROM employees e, salaries s
    WHERE s.emp_no=e.emp_no
    GROUP BY e.last_name;
```
- employees 테이블의 Extra 컬럼에 `Using temporary` 메시지가 표시된다.
  - `Using filesort`는 표시되지 않은 이유
    - MySQL 8.0 이전까지는 GROUP BY가 사용된 컬럼을 기준으로 묵시적인 정렬까지 함께 수행됨
    - MySQL 8.0 부터는 이러한 묵시적인 정렬은 더 이상 실행되지 않게 바뀜
- employees 테이블을 풀 스캔하는 것이 아닌 인덱스를 전혀 사용할 수 없는 GROUP BY라서 임시 테이블이 사용되었다.
- MySQL 8.0에서는 GROUP BY가 필요한 경우 내부적으로 GROUP BY 절의 컬럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어서 중복 제거, 집합 함수 연산을 수행한다.
- 조인의 결과를 한 건씩 가져와 임시 테이블에서 중복 체크를 하면서 INSERT or UPDATE를 실행한다.
- 별도의 정렬 작업은 없음
- `ORDER BY` `GROUP BY`가 같이 사용되면 명시적으로 정렬 작업을 실행한다.

# 9.2.5 DISTINCT 처리
> 특정 컬럼의 유니크한 값만 조회하려면 SELECT 쿼리에 DISTINCT를 사용한다.
- MIN(), MAX(), COUNT() 같은 집합 함수와 함께 사용되는 경우 vs 집합 함수가 없는 경우
  - 각 경우에 DISTINCT 키워드가 영향을 미치는 범위가 다르다.
  - 집합 함수와 함께 사용되는 쿼리의 실행 계획에서 DISTINCT 처리가 인덱스를 사용하지 못할 때는 항상 임시 테이블이 필요하다.
  - 실행 계획의 Extra 컬럼에는 `Using temporary` 메시지가 표시되지 않는다.

## 9.2.5.1 SELECT DISTINCT
> 유니크한 레코드만 가져올 때 사용, GROUP BY와 동일한 방식으로 처리된다.
- MySQL 8.0 부터는 GROUP BY를 수행하는 쿼리에 ORDER BY절이 없으면 정렬을 사용하지 않기 때문에 두 쿼리는 내부적으로 같은 작업을 수행한다.
  - ```sql
      SELECT DISTINCT emp_no FROM salaries;
      SELECT emp_no FROM salaries GROUP BY emp_no;
    ```
- DISTINCT는 SELECT하는 레코드를 유니크하게 조회하는 것이고, 특정 컬럼만 유니크하게 조회하는 것이 아님
  - ```sql
      -- (first_name, last_name) 전체가 유니크한 레코드를 조회함
      SELECT DISTINCT first_name, last_name FROM employees;
      SELECT DISTINCT(first_name), last_name FROM employees;
      -- 둘은 같은 쿼리
    ```

## 9.2.5.2 집합 함수와 함께 사용된 DISTINCT
> COUNT(), MIN(), MAX() 같은 집합 함수 내에서 DISTINCT 키워드가 사용됨
- 집합 함수의 인자로 전달된 컬럼값이 유니크한 레코드를 가져온다.
- ```sql
    EXPLAIN SELECT COUNT(DISTINCT s.salary)
    FROM employees e, salaries s
    WHERE e.emp_no=s.emp_no
    AND e.emp_no BETWEEN 100001 AND 100100;
  ```
  - `COUNT(DISTINCT s.salary)`를 처리하기 위해 임시 테이블을 사용하지만 쿼리 실행 계획에는 `Using temporary` 메시지를 표시하지 않는다.
    - 모든 버전의 MySQL 서버에서 해당 메시지를 표시하지 않는다.
  - 쿼리에 `COUNT(DISTINCT)` 하나를 추가
    - ```sql
        SELECT COUNT(DISTINCT s.salary),
               COUNT(DISTINCT e.last_name)
        FROM employees e, salaries s
        WHERE e.emp_no=s.emp_no
        AND e.emp_no BETWEEN 100001 AND 100100;
      ```
      - s.salary, e.last_name 컬럼의 값을 저장하는 임시테이블 1개씩 총 2개 사용
  - 인덱스된 컬럼에 대해 DISTINCT 처리를 수행할 때는 인덱스를 풀 스캔하거나 레인지 스캔하면서 임시 테이블 없이 최적화된 처리를 수행할 수 있음

# 9.2.6 내부 임시 테이블 활용
> MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적인 임시 테이블을 사용한다.
- `CREATE TEMPORARY TABLE` 명령으로 만든 임시 테이블과는 다름
- 다른 세션이나 쿼리에서는 볼 수 없고, 사용할 수도 없다.
- 쿼리의 처리가 완료되면 자동으로 삭제된다.

## 9.2.6.1 메모리 임시 테이블과 디스크 임시 테이블
- MySQL 8.0 이전까지는 임시 테이블이 메모리 사용 시 MEMORY 스토리지 엔진을 사용하고, 디스크에 저장 시 MyISAM 스토리지 엔진을 사용했다.
- MySQL 8.0 부터는 메모리는 TempTable 스토리지 엔진을 사용하고, 디스크에 저장되는 임시 테이블은 InnoDB 스토리지 엔진을 사용하도록 개선됐다.
- TempTable이 최대한 사용 가능한 메모리 공간의 크기는 temptable_max_ram 시스템 변수로 제어, 기본값은 1GB
  - 임시 테이블의 크기가 temptable_max_ram보다 커지면 MySQL 서버는 메모리의 임시 테이블을 디스크로 기록하게 된다. (2가지 디스크 저장 방식 중 하나 선택)
    - MMAP 파일로 디스크에 기록
    - InnoDB 테이블로 기록
    - `temptable_use_mmap` 시스템 변수로 설정 (기본값은 on)
    - MMAP 방식이 오버헤드가 상대적으로 적음

## 9.2.6.2 임시 테이블이 필요한 쿼리
> MySQL 엔진에서 별도의 데이터 가공 작업을 필요로 하므로 대표적으로 내부 임시 테이블을 생성하는 케이스
1. `ORDER BY`와 `GROUP BY`에 명시된 컬럼이 다른 쿼리
2. `ORDER BY`나 `GROUP BY`에 명시된 컬럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
3. `DISTINCT`와 `ORDER BY`가 동시에 쿼리에 존재하는 경우 또는 `DISTINCT`가 인덱스로 처리되지 못하는 쿼리
4. `UNION`이나 `UNION DISTINCT`가 사용된 쿼리 (`select_type` 컬럼이 `UNION RESULT`인 경우)
5. 쿼리의 실행 계획에서 `select_type`이 `DERIVED`인 쿼리
- 임시 테이블을 사용하는 쿼리에 대해 Extra 컬럼에 `Using temporary` 메시지가 표시되는지 확인
  - 3 ~ 5는 표시되지 않을 때도 임시 테이블을 사용할 수 있음
- 1 ~ 4는 유니크 인덱스를 가지는 내부 임시 테이블이 만들어진다.
  - 5에 비해 상대적으로 처리 성능이 상당히 느리다.
- 5는 유니크 인덱스가 없는 내부 임시 테이블이 만들어진다.

## 9.2.6.3 임시 테이블이 디스크에 생성되는 경우
- 내부 임시 테이블은 기본적으로 메모리 상에 만들어진다.
- 아래 조건을 만족하면 메모리 임시 테이블을 사용할 수 없게 되고, 디스크 기반의 임시 테이블을 사용한다.
  - `UNION`이나 `UNION ALL`에서 SELECT되는 컬럼중에서 길이가 512바이트 이상인 크기의 컬럼이 있는 경우
  - `GROUP BY`나 `DISTINCT` 컬럼에서 512바이트 이상인 크기의 컬럼이 있는 경우
  - (MEMORY 스토리지 엔진) 메모리 임시 테이블의 크기가 `tmp_table_size` or `max_heap_table_size` 시스템 변수보다 크거나 (TempTable 스토리지 엔진) `temptable_max_ram` 시스템 변수 값보다 큰 경우

## 9.2.6.4 임시 테이블 관련 상태 변수
- 실행 계획상에서 `Using temporary`가 표시되면 임시 테이블을 사용했다는 사실을 알 수 있다.
- 임시 테이블이 메모리에서 처리됐는지 디스크에서 처리됐는지는 알 수 없다.
- 몇 개의 임시 테이블이 사용됐는지 알 수 없다.
- MySQL 서버의 상태 변수를 확인한다.
  - ```sql
      -- 현재 세션의 상태 값을 초기화한다.
      FLUSH STATUS;

      SELECT first_name, last_name
      FROM employees
      GROUP BY first_name, last_name;

      SHOW SESSION STATUS LIKE 'Created_tmp%';
    ```
    - `Created_tmp_tables`: 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 갯수를 누적하는 상태 값
    - `Created_tmp_disk_tables`: 디스크에 내부 임시 테이블이 만들어진 갯수만 누적하는 상태 값
